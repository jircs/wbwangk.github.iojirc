Efficient RSA Key Generation and Threshold Paillier in the Two-Party Setting 

Carmit Hazay∗ Gert Læssøe Mikkelsen∗ Tal Rabin† Tomas Toft∗ 

Abstract 

The problem of generating an RSA composite in a distributed manner without leaking its factorization is particularly challenging and useful in many cryptographic protocols. Our first contribution is the first non-generic fully simulatable protocol for distributively generating an RSA composite with security against malicious behavior. Our second contribution is complete Paillier [Pai99] threshold encryption scheme in the two-party setting with security against malicious behavior. Furthermore, we describe how to extend our protocols to the multiparty setting with dishonest majority. 

Our RSA key generation is comprised of the following: (i) a distributed protocol for generation of an RSA composite, and (ii) a biprimality test for verifying the validity of the generated composite. Our Paillier threshold encryption scheme uses the RSA composite as public key and is comprised of: (i) a distributed generation of the corresponding secret-key shares and, (ii) a distributed decryption protocol for decrypting according to Paillier. 

1 Introduction 

Generation of RSA Composite. 

Generating an RSA composite, N, (a product of two primes, p and q), and secret keying material (values related to ϕ(N)) in a distributed manner is an important question in secure computation. Many cryptographic protocols require such a composite for which none of the parties know its factorization. A concrete example where such a protocol is very useful is threshold cryptography where a number of parties exceeding a threshold is required to cooperate in order to carry out a cryptographic task; see [Rab98, Des94, Sho00, CDN01] for just a few particular examples. Another important application is using this composite for securely evaluating any function in the common reference string model (CRS) in a generic form [JS07], or functions of specific interests such as the Fiat-Shamir authentication protocol [FS86, FFS88], set-intersection [JL09] and oblivious pseudorandom functions [JL09]. 

This computation has proven particularly challenging and most prior works assumed that the composite is generated by a trusted dealer. In a breakthrough result, Boneh and Franklin [BF01] showed a mathematical method for choosing a composite and verifying that it is of the proper form. Based on this method they designed a secure protocol in the multiparty setting for an honest-but-curious adversary with honest majority. Frankel et al. [FMY98] strengthened this result to be resistant to a fully malicious adversary. Additional solutions for testing primality in the multiparty setting appear in [ACS02, DM10]. 

The two party setting posed additional barriers even in the semi-honest model. Cocks [Coc97] initiated the study of the shared generation of the RSA composite in the two-party semi-honest model. But the proposed protocol was later found to be insecure [Cop97, BBBG]. The problem was finally solved by Gilboa [Gil99] who presented a protocol in the semi-honest model. 

In the malicious setting, Blackburn et al. [BBBG] started examining the setting of an arbitrary adversary, yet they do not provide a proof of security for their protocol. Concurrently, Poupard and Stern [PS98] proposed a solution that runs in time proportional to the size of the domain from which the primes are sampled, which is exponential in the security parameter. Furthermore, a second minor limitation is a requirement that one of the steps be computed in complete simultaneity. This probably can be fixed by adding commitments. They attempt to somewhat reduce the run time by introducing various modifications, however those are not proven, and as they leak some information presenting a proof of security (if at all possible) will not be a trivial thing. A detailed explanation about this construction and a discussion about the complexity of proving it appear in Appendix A. Thus, all these results do not offer an efficient and provable solution for the two-party malicious case. 

Our first result. The first RSA key generation in the malicious setting which is an efficient, (nongeneric) protocol with a full simulation based proof of security. 

Threshold Paillier. 

A threshold cryptosystem usually involves two related yet separable components; (1) a distributed generation of the public keys and a sharing of the secret key of the cryptosystem and, (2) a decryption/signature computation from a shared representation of the secret key. Solutions for distributed discrete log based system key generation [GJKR07], threshold encryption/decryption for RSA [GKR00, Sho00], DSS [GJKR01] and Paillier [FPS00, DJ01, BFP+01] in the multiparty setting have been presented. For some cryptosystems the techniques from the multiparty setting can be adapted to the two-party case in a more-or-less straightforward manner. However, here again the solution for the malicious two-party Paillier has proven more complex and elusive. 

More specifically, as the RSA and Paillier encryption schemes share the same public key/secret key format of a composite N and its factorization, it may seem at first glance that decryption according to Paillier should follow the same outlines as decryption according to RSA as e.g., in [CGHN01]. We observe that when decrypting as in RSA (i.e., raising the ciphertext to the inverse of N modulo the unknown order), the decrypter must extract the randomness used for computing the ciphertext in order to complete the decryption. This property may be problematic in the secure computation context, especially when simulation based security is required. This is due to the fact that it forces the simulator to present the randomness of the ciphertext instead of cheating by proving correctness of “decryption”, using ZK proofs. In addition we recall that by definition, Pallier’s scheme requires extra work in order to decrypt (on top of raising the ciphertext to the power of the secret value since the outcome from this computation is the plaintext multiplied with this secret value). This means that in the distributive setting, the parties must keep two types of shares in order to decrypt properly. When coping with malicious behavior it is not immediately clear how to efficiently verify the parties’ computations. Not even when using an RSA type decryption. 

Our second result. The first threshold Pailler in the malicious setting which is an efficient, (non-generic) protocol with a full simulation based proof of security. 

Our contribution (with a bit more details). In this work, we present the first fully simulatable and complete RSA key generation and Paillier [Pai99] threshold scheme in the two-party malicious setting. Namely, we define the appropriate functionalities and prove that our protocols realize them. Our formalization takes into account a subtle issue in the public key generation, which was noticed by Boneh and Franklin [BF01]. Informally, they showed that their protocol leaks certain amount of information about the product and further proved that it does not pose any practical threat for the security. Nevertheless, it does pose a problem when simulating, since the adversary can influence the distribution of the generated public key. We therefore choose to work with a slightly modified version of the natural definition for a threshold encryption functionality. Our scheme is comprised of the following protocols: 

1. A distributed generation of an RSA composite. We present the first fully simulatable protocol for securely computing a Blum integer composite as a product of two primes without leaking information about its factorization. Our protocol follows the outlines of [BF01] and improves the construction suggested by [Gil99] in terms of security level and efficiency; namely we introduce an additional trial division protocol on the individual candidates for primes, which enables us to exclude many of them earlier in the computation. We note that [Gil99] did not achieve the trial division in the two party setting, thus our solution is the first for the two-party setting that achieves that. Here we take, a novel approach of utilizing two different additively homomorphic encryption schemes, giving us active security at a very low cost. In Appendix E we further show how to extend this protocol and the biprimality test to the multiparty setting with dishonest majority, presenting the first actively secure k parties RSA generation protocol, that tolerates up to k − 1 corruptions. 

2. A distributed biprimality test. We adopt the biprimality test proposed by [BF01] into the malicious two-party setting. This test essentially verifies whether the generated composite is of the correct form (i.e., it is a product of exactly two primes of an appropriate length). We provide a proof of security for this protocol. We note that although the biprimality test by Damgard and Mikkelsen [DM10] has ˚ a better error estimate, it cannot be used directly in the two-party setting with malicious adversaries. In the full version of this paper we show how to adapt their test into the two-party setting when the parties are semi-honest. 

3. Distributed generations of the secret key shares. We present two protocols for generating additive and multiplicative shares for ϕ(N). The generation of the initial additive shares follows from the public key generation almost immediately, whereas the generation of the multiplicative shares is a more challenging task. This is due to the fact that generating these over the integers may lead to a complete break of the security of our scheme. 

4. A distributed decryption. Motivated by the discussion above, we present a distributed protocol for decrypting according to Paillier. Our protocol takes a different approach than traditionally proving computations using zero-knowledge proofs. 

Efficiency. We provide a detailed efficiency analysis for all our subprotocols in Section 6. Roughly speaking, all our subprotocols have constant round complexity due to parallelization of the generation of RSA composites, including the biprimality tests and trial division, and the decryption of multiple instances. Moreover, all our zero-knowledge proofs (except one that achieves constant complexity on the average) run in constant rounds and require constant number of exponentiations. 

We note that the probability of finding a random prime is independent of the method in which it is generated, but rather only depended on the density of the primes in a given range. Thus, in comparing our results to generic solutions [JS07, IPS09, LP10], on this front we fare the same as those solutions. However, due to our optimizations (cf. Section 6) we gain an advantage over the generic protocols. The fact that we are able to do the trial division greatly reduces the number of candidates that we are expected to test, e.g. for a 512 bit prime we would need to test about 31,000 candidates without the trial division and with it the number would be reduced to 484. We further note that the generic constructions in [JS07, LP10], which operate over a binary circuit, require a circuit of size O(n log n) (for security parameter n), for computing a single multiplication. In [LP10] this overhead is further increased by a statistical parameter due to the cut-and choose technique and in [JS07] by approximately 720 RSA exponentiations per gate in (where these operations are computed modulo 2048 due to the Paillier’s encryption scheme). In addition to the above, [JS07] requires a common reference string which consists of a strong RSA modulus. As for [IPS09], which securely evaluates arithmetic circuits over finite rings (and fields), the asymptotic costs require an additive statistical parameter. In contrast, our protocols achieve constant overhead on the average per invocation, independently of the security parameter; see Section 6 for further details. 

2 Preliminaries 

We denote the security parameter by n. A function µ(·) is negligible in n (or just negligible) if for every polynomial p(·) there exists a value m such that for all n > m it holds that µ(n) < 1 p(n) . Let X = {X(n, a)}n∈N,a∈{0,1} ∗ and Y = {Y (n, a)}n∈N,a∈{0,1} ∗ be distribution ensembles. Then, we say that X and Y are computationally indistinguishable, denoted X c ≡ Y , if for every non-uniform probabilistic polynomial-time distinguisher D there exists a negligible function µ(·) such that for every a ∈ {0, 1} ∗ , 

|Pr[D(X(n, a)) = 1] − Pr[D(Y (n, a)) = 1]| < µ(n) 

We adopt the convention whereby a machine is said to run in polynomial-time if its number of steps is polynomial in its security parameter alone. We use the shorthand PPT to denote probabilistic polynomialtime. 

In Appendix B we present the definition of secure multiparty computation used in this work. The definition is based on [Gol04, Chapter 7], and is rather standard, so most readers will probably be familiar with the definition. 

2.1 Hardness Assumptions 

Our constructions rely on the following hardness assumptions. 

Definition 1 (DDH) We say that the decisional Diffie-Hellman (DDH) problem is hard relative to G = {Gn} if for all polynomial-sized circuits A = {An} there exists a negligible function negl such that    

Pr [A(G, q, g, gx , gy , gz ) = 1] − Pr [A(G, q, g, gx , gy , gxy) = 1]    
 ≤ negl(n), 

where q is the order of G and the probabilities are taken over the choices of g and x, y, z ∈ Zq. 

We require the DDH assumption to hold for prime order groups. 

Definition 2 (DCR) We say that the decisional composite residuosity (DCR) problem is hard if for all polynomial-sized circuits A = {An} there exists a negligible function negl such that    

Pr [ A(N, z) = 1|z = y N mod N 2 ] − Pr [ A(A(N, z) = 1|z = (1 + N) r · y N mod N 2 ]    
 ≤ negl(n), 

where N is a random n-bit RSA composite, r is chosen at random in ZN , and the probabilities are taken over the choices of N, y and r. 

2.2 Public Key Encryption Schemes 

We begin by specifying the definitions of public key encryption and semantic security. We conclude this section with a definition for homomorphic encryption, specifying two encryption schemes that meets this definition. 

Definition 3 (PKE) We say that Π = (Gen, Enc, Dec) is a public-key encryption scheme if Gen, Enc, Dec are polynomial-time algorithms specified as follows: 

• Gen, given a security parameter n (in unary), outputs keys (pk, sk), where pk is a public key and sk is a secret key. We denote this by (pk, sk) ← Gen(1n ). 

• Enc, given the public key pk and a plaintext message m, outputs a ciphertext c encrypting m. We denote this by c ← Encpk(m); and when emphasizing the randomness r used for encryption, we denote this by c ← Encpk(m; r). 

• Dec, given the public key pk, secret key sk and a ciphertext c, outputs a plaintext message m s.t. there exists randomness r for which c = Encpk(m; r) (or ⊥ if no such message exists). We denote this by m ← Decpk,sk(c). 

For a public key encryption scheme Π = (Gen, Enc, Dec) and a non-uniform adversary A = (A1, A2), we consider the following Semantic security game: 

(pk, sk) ← Gen(1n ). 

(m0, m1, history) ← A1(pk), s.t. |m0| = |m1|. 

c ← Encpk(mb), where b ∈R {0, 1}. 

b ′ ← A2(c, history). 

A wins if b ′ = b. 

Denote by AdvΠ,A(n) the probability that A wins the semantic security game. 

Definition 4 (Semantic security) A public key encryption scheme Π = (Gen, Enc, Dec) is semantically secure, if for every non-uniform adversary A = (A1, A2) there exists a negligible function negl such that AdvΠ,A(n) ≤ 1 2 + negl(n). 

An important tool that we exploit in our construction is homomorphic encryption over an additive group as defined below. 

Definition 5 (Homomorphic PKE) A public key encryption scheme (Gen, Enc, Dec) is homomorphic if for all n and all (pk, sk) output by Gen(1n ), it is possible to define groups M, C such that: 

• The plaintext space is M, and all ciphertexts output by Encpk are elements of C. 

• For any m1, m2 ∈ M and c1, c2 ∈ C with m1 = Decsk(c1) and m2 = Decsk(c2), it holds that {pk, c1, c1 ·c2} ≡ {pk, Encpk(m1), Encpk(m1 + m2)} 

where the group operations are carried out in C and M, respectively, and the encryptions of m1 and m1 + m2 use independent randomness. 

Any additive homomorphic scheme supports the multiplication of a ciphertext by a scalar by computing multiple additions. 

2.2.1 The Paillier Encryption Scheme 

The Paillier encryption scheme [Pai99] is an example of a public key encryption scheme that meets Definition 5. We focus our attention on the following, widely used, variant of Paillier comprised of(Gen, Enc, Dec). Namely, the key generation algorithm, Gen, chooses two equal length primes p and q and outputs a public key pk that equals N = pq, and a matching secret-key sk = ϕ(N). Furthermore, the encryption procedure of a message m ∈ ZN , denoted Encpk(m), is performed by choosing r ∈R Z ∗ N (ZN in practice), and computing (1 + N) m · r N mod N2 , whereas decrypting is performed by, 

Decsk(c) = [c ϕ(N) mod N2 ] − 1 N · ϕ(N) −1 mod N 

The security of Paillier is implied by the Decisional Composite Residuosity Assumption (DCR). 

2.2.2 Additively Homomorphic ElGamal Variant 

In our protocols we use an additively homomorphic variation of ElGamal encryption [ElG85]. Namely, let G be a group generated by g of prime order Q, in which the decisional Diffie-Hellman (DDH) problem is hard. A public key is then a pair pk = (g, h) and the corresponding secret key is s = logg (h), i.e. g s = h. Encryption of a message m ∈ ZQ is defined as Encpk(m; r) = (g r , hr · g m) where r is picked uniformly at random in ZQ. Decryption of a ciphertext (α, β) is then performed as Decsk(α, β) = β · α −s . Note that decryption yields g m rather than m. As the discrete log problem is hard, we cannot in general hope to determine m. Fortunately, we only need to distinguish between zero and non-zero values, hence the lack of “full” decryption is not an issue. We abuse notation and write c · c ′ to denote the componentwise multiplication of two ciphertexts c and c ′ , computed by (α · α ′ , β · β ′ ), where c = (α, β) and c ′ = (α ′ , β′ ). 

We require that the parties run a threshold version for ElGamal for generating a public key and additive shares for the secret key, as well as a distributive decryption protocol. The key generation construction can be easily obtained based on the Diffie-Hellman protocol [DH76] with additive shares. A distributive decryption follows easily as well; see [HT10] for a complete description of distributive key generation and decryption protocols. Denote the distributed key generation protocol by πGEN and the distributed decryption protocol by πDEC. 

2.3 Integer Commitment Schemes 

In order to ensure correct behavior of the parties (and do so efficiently), our key generation protocol utilizes integer commitments which relies on the fact that the committer does not know the order of the group G, denoted by |G|, from which it picks the committed elements. Therefore, it cannot decommit into two different values m and m + |G|. This property is crucial for ensuring that the parties’ shares are indeed smaller than some threshold. An example of such a commitment is the Paillier based scheme of Damgard ˚ and Nielsen [DN02, DN03], which is comprised of the following two algorithms: 

1. SETUP. The receiver, R, generates a Paillier key, N, i.e. an RSA modulus. It then picks r at random in Z ∗ N2 , computes g = r N , and sends N, g to the committing party, C, along with zero-knowledge proofs that N is an RSA modulus, and that g is a Paillier encryption of zero (cf. Section 3). 

2. COMMIT/OPEN. To commit to m ∈ ZN , C picks rm at random in ZN and computes Com (m; rm) = g m · r N m. To open, C simply reveals rm and m to R. 

HIDING/BINDING. The scheme is perfectly hiding, as a commitment is simply a random encryption of zero. Further, opening to two different values implies an N’th root of g (which breaks the underlying assumption of Paillier, i.e., DCR). 

2.4 Σ-protocols 

Definition 6 (Σ-protocol) A protocol π is a Σ-protocol for relation R if it is a 3-round public-coin protocol and the following requirements hold: 

• COMPLETENESS: If P and V follow the protocol on input x and private input w to P where (x, w) ∈ R, then V always accepts. 

• SPECIAL SOUNDNESS: There exists a polynomial-time algorithm A that given any x and any pair of accepting transcripts (a, e, z),(a, e′ , z′ ) on input x, where e ̸= e ′ , outputs w such that (x, w) ∈ R. 

• SPECIAL HONEST-VERIFIER ZERO KNOWLEDGE: There exists a PPT algorithm M such that 

{ ⟨P(x, w), V (x, e)⟩ } x∈LR ≡ { M(x, e) } x∈LR 

where M(x, e) denotes the output of M upon input x and e, and ⟨P(x, w), V (x, e)⟩ denotes the output transcript of an execution between P and V , where P has input (x, w), V has input x, and V ’s random tape (determining its query) equals e. 

3 Building Blocks: Zero-Knowledge Proofs 

In order to cope with malicious adversaries, our protocols employ zero-knowledge (ZK) proofs. In this section we provide an informal description of the proofs we use; while some of these proofs are known, others are new to this work and are interesting by themselves. We note that except from a single proof, all proofs require a strict constant overhead. Fortunately, since our proofs are employed for multiple instances, the analysis of [CD09] ensures that the average overhead is constant. 

3.1 Discrete Logarithms 

1. The following Σ-protocol, denoted by πDL, demonstrates knowledge of a discrete logarithm. The proof follows due to Schnorr [Sch91]. RDL = {((G, g, h), w) | h = g w} . 

2. The Σ-protocol πDH demonstrates that a quadruple (g0, g1, h0, h1) is a Diffie-Hellman tuple, i.e. that logg0 (h0) = logg1 (h1) for gi , hi ∈ G. This proof is due to Chaum and Pedersen [CP92]. RDH = {((G, g0, g1, h0, h1) w) | hi = g w i for i ∈ {0, 1}} . 

3.2 Public Key Cryptosystems (and Commitment Schemes) 

1. Protocol πENC demonstrates knowledge of the plaintext of an encryption. 

RENC = {((c, pk),(α, r)) | c = Encpk(α; r)} . 

The protocols are due to Schnorr [Sch91] (for ElGamal encryption) and Cramer et al. [CDN01] (for Paillier encryption). 

2. Protocol πZERO demonstrates that a ciphertext c is an encryption of zero is captured by the following language. 

LZERO = {((c, pk), r) | c = Encpk(0; r)} . 

For ElGamal this is merely πDH, demonstrating that the key and ciphertext are a Diffie-Hellman tuple. For Paillier encryption this is a proof of N’th power shown by [DJ01]. 

3. The zero-knowledge proof of knowledge πMULT proves that the plaintext of c2 is the product of the two plaintexts encrypted by c0, c1. More formally, 

RMULT = {((c0, c1, c2, pk),(α, rα, r0)) | c1 = Encpk(α; rα) ∧ c2 = c α 0 · Encpk(0; r0)} ; 

This proof due to Damgard and Jurik [DJ01] (for both Paillier and ElGamal). Note also, that this is ˚ not applicable in the case of commitments, though a similar proof of knowledge is possible when the contents of all three commitments are known, [DN02, DN03]; this is required in πBOUND below. 

4. Protocol πBOUND demonstrates boundedness of an encrypted value, i.e. that the plaintext is smaller than some public threshold B. Formally, 

LBOUND = {((c, pk, B),(α, r)) | c = Encpk(α; r) ∧ α < B ∈ N} . 

The “classic” solution is to provide encryptions to the individual bits and prove in zero-knowledge that they are bits using the compound proof of Cramer et al. [CGS97]. The actual encryption is then constructed from these. 

An alternative is to take a detour around integer commitments; this allows a solution requiring only O(1) exponentiations [Bou00, Lip03, DJ02]. Sketching the solution, the core idea is to commit to α using a homomorphic integer commitment scheme; the typical suggestion is schemes such as [FO97, DF02]. The prover then demonstrates that α and B − 1 − α are non-negative (using the fact that any non-negative integer can be phrased as the sum of four squares), implying that 0 ≤ α < B. Finally, the prover demonstrates that the committed value equals the encrypted value. For simplicity, we may use the commitment scheme of Section 2.3. Note that for small B, the classic approach may be preferable in practice. 

5. The proof πEQ is of correct exponentiation in the group G′ with encrypted exponent (where the encryption scheme does not utilize the description of G′ ). Formally, 

REQ = {((c, pk, G ′ , h, h′ ),(α, r) ) | α ∈ N ∧ c = Encpk(α; r) ∧ h, h′ ∈ G ′ ∧ h ′ = h α } . 

The protocol is a simple cut and choose approach. The prover selects a random s, rs and sends cs = Encpk(s, rs) and h s to the verifier, who returns a random, one bit challenge, b. The prover then replies with α · b + s and r b · rs, i.e. it “opens” either s or s + m. It is only possible to answer both challenges if the statement is well-formed; the protocol is repeated in order to obtain a suitable level of security and obtains constant amortized costs when instantiated with the technique of [CD09]. This proof was already considered in [CKY09]. 

3.3 New Zero-Knowledge Proofs 

1. We include the folklore protocol πRSA for proving that N and ϕ(N) are co-prime for some integer N, i.e. the protocols demonstrate membership of the language, 

LRSA = {(N,(factorization of N)) | N ∈ N ∧ GCD (N, ϕ(N)) = 1} . 

The solution is to let the verifier pick x = y N and prove knowledge of an N’th root (essentially execute the Paillier version of πZERO). The prover (who generated N) returns an N’th root y ′ . If the GCD is 1, then y is unique, hence y = y ′ . Otherwise there are multiple candidates, and the probability that y = y ′ is ≤ 1/2. This is repeated (in parallel) until a sufficiently low probability is reached. We note that this protocol is used only once, therefore its overhead does not influence the analysis. Constructing a simulator is straightforward by simply extracting y first and then sending it to the verifier. 

2. We also require a zero-knowledge proof, πMOD, for proving consistency between two ciphertexts in the sense that one plaintext is the other one reduced modulo a public, fixed value (prime). This is required for proving correctness within the trial division stage included in the key generation protocol (cf. Section 4). Formally, 

LMOD = {((c, c′ , p, pk),(α, r, r′ ) ) | c = Encpk(α; r) ∧ c ′ = Encpk(α mod p; r ′ ) } . 

Informally, the parties additionally compute c ′′ = ( c · (c ′ ) −1 )p−1 , which is an encryption of α div p (assuming that c ′ is correct). The prover then executes πBOUND twice, on (c ′ , p) and on (c ′′ , ⌈M/p⌉), where M is an upper bound on the size of α. This demonstrates that α has been decomposed correctly, i.e. that the division has been performed correctly. 

3. For public Paillier key N, we require Σ-protocol πEXP−RERAND that allows a prover to demonstrate that ciphertext c ′ is in the image of ϕ : ZN × Z ∗ N2 7→ Z ∗ N2 , defined by ϕ(a, r) = c a · r N mod N2 for a fixed ciphertext c ∈ Z ∗ N2 . Namely, 

LEXP−RERAND = {((N, c, c′ ) ,(α, r) ) | c ′ = c α · r N } 

In order to demonstrate this, the prover picks v, rv at random, and sends A = ϕ(v, rv) to the verifier, who responds with a challenge e < N. The verifier then replies with (z1, z2) = (ae + v, re rv), and the verifier checks that ϕ(z1, z2) = (c ′ ) e · A. 

This is a Σ-protocol. To see this, note first that it is straightforward to verify completeness. Special soundness follows from the fact that for two accepting conversions (A, e,(z1, z2)) and (A, e′ ,(z ′ 1 , z′ 2 )) with e ̸= e ′ , we may find integers α, β such that α(e−e ′ ) +βN = 1 using Euclid’s algorithm (unless (e−e ′ , N) are not co-prime, which implies that we have found a factor of N). It is easily verified that (α(z1 − z ′ 1 ); (z2/z′ 2 ) α ·(c ′ ) β ) is a preimage of c ′ . Finally, the simulator for the special honest-verifier zero-knowledge is straightforward: given a commitment, pick (z1, z2) at random and compute A. 

3.3.1 A Zero-Knowledge Proof for πVERLIN 

In this section we give the details of ZK proof πVERLIN used in Step 3a of Protocol 1. Let NP be a public Paillier key, with g = NP + 1 generating the plaintext ring. πVERLIN is a Σ-protocol allowing a prover P to demonstrate to a verifier V that a Paillier ciphertext, cx has been computed based on two other ciphertexts c and c ′ as well as a known value, i.e. that P knows a preimage of cx with respect to 

ϕ(c,c′) ( x, x′ , x′′, rx ) = c x · c ′x ′ · Enc ( x ′′, rx ) . 

This is done by first picking a, a′ , a′′ uniformly at random from ZNP and ra uniformly at random from Z ∗ NP , and sending 

ca = ϕ(c,c′) ( a, a′ , a′′, ra ) 

to the verifier, V . V then picks a uniformly random t-bit challenge,1 e, and sends this to P, who replies with the tuple 

( z, z′ , z′′, rz ) = ( xe + a, x′ e + a ′ , x′′e + a ′′, re x ra ) . 

V accepts if and only if ϕ(c,c′) (z, z′ , z′′, rz) = c e x · ca. 

Proposition 3.1 Assuming hardness of the DCR problem, πVERLIN is a Σ-protocol with constants costs. 

Proof: We prove that all three properties required for Σ-protocols (cf. Definition 6) are met. 

Completeness. An honest prover always convinces the verifier, since 

ϕ(c,c′) ( z, z′ , z′′, rz ) = ϕ(c,c′) ( xe + a, x′ e + a ′ , x′′e + a ′′, re x ra ) 

= c xe+a · c ′x ′e+a ′ · g x ′′e+a ′′ · (r e x ra) NP 

= ( c x · c ′x ′ · g x ′′ · r NP x )e · ( c a · c ′a ′ · g a ′′ · r NP a ) 

= c e x · ca 

Special soundness. A preimage of cx may be computed given two accepting conversations with same initial message, ca, and differing challenges e ̸= ¯e. Denote the final messages of the two executions (z, z′ , z′′, rz) and (¯z, z¯ ′ , z¯ ′′, rz¯), and compute integers α and β such that 

α (e − e¯) + β · NP = 1 

using the extended Euclidian algorithm. This is always possible as e − e¯ and NP are co-prime. It is straightforward but tedious to verify that 

( α (z − z¯), α ( z ′ − z¯ ′ ) , α ( z ′′ − z¯ ′′) , ( rz · r −1 z¯ )α · (cx mod NP ) β ) 

1Choose t such that 2 t is smaller than any prime factor of NP . This guarantees that the difference between challenges is co-prime to NP . 

 is a preimage of cx, briefly 

ϕ(c,c′) ( α (z − z¯), α ( z ′ − z¯ ′ ) , α ( z ′′ − z¯ ′′) , ( rz · r −1 z¯ )α · (cx mod NP ) β ) 

= (c e x · ca) α / ( c e¯ x · ca )α · ( (cx mod NP ) β )NP 

= c α(e−e¯) x · c β·NP x 

= cx. 

Special Honest-Verifier Zero-knowledge. Accepting transcripts are easily simulated. Given challenge e, pick z, z′ , z′′ uniformly at random from ZNP and rz uniformly at random from Z ∗ NP . Then, compute 

ca = ϕ(c,c′) ( z, z′ , z′′, rz ) · c −e x . 

Clearly, this is an accepting conversation. Moreover, for preimage (x, x′ , x′′, rx) (i.e., the witness), 

( z − ex, z′ − ex′ , z′′ − ex′′, rz · r −e x ) 

is uniformly random, and a preimage of ca, i.e. it corresponds to the choice of (a, a′ , a′′, ra); hence ca is distributed as in the real protocol. Finally, given this random choice and a witness, (z, z′ , z′′, rz) is exactly the final message that an honest prover would send. 

4 A Distributed Generation of an RSA Composite 

This section presents a protocol, denoted DKeyGen, for distributively generating an RSA composite without disclosing any information about its factorization and with security against malicious activities. In this protocol the parties generate candidates for the potential composite which they run through a biprimality test for checking its validity. Our protocol is useful for designing distributive variants of the RSA encryption and signature schemes, as well as other schemes that rely on factoring related hardness assumptions. In this paper we use this protocol for distributively generating the public key for Paillier [Pai99] encryption scheme. The starting point for DKeyGen is the protocols of [BF01, Gil99]. These protocols are designed to distributively generate an RSA composite N = p · q with an unknown factorization. The protocol by Boneh and Franklin [BF01] assumes honest majority, whereas the protocol by Gilboa [Gil99] adopts ideas from [BF01] into the two-party setting; both are secure in the semi-honest setting. 

Recall that when coping with malicious adversaries it must be assured that the parties follow the protocol specifications. In our context this means that the parties’ shares must be of the appropriate length and that no party gains any information about the factorization of N, even by deviating.2 This challenging task is typically addressed by adding commitments and zero-knowledge proofs to each step of the protocol. Unfortunately, this is usually not very practical since the statements that needed to be proven are complicated, and therefore leading to highly inefficient protocols. Instead, we will be exploiting specific protocols for our tasks (some new to this work), that are both efficient and fully secured. By proper analysis of where to use zero knowledge proofs, which proofs to use and moreover, by a novel technique of utilizing two different encryption schemes with different homomorphic properties, we achieve a highly efficient key generation protocol. It should be noted that except for the setup step which is only executed ones we can avoid expensive zero knowledge proofs based on the cut and choose technique. Additional optimizations can be found in Section 6. 

2As noted above, in some settings early abort may not be considered as a breach of security (even if the abort occurs as a result of gaining information about the factorization of the public key). This is due to the fact that the honest party halts as well, outputting ⊥. Thus, essentially, no damage was caused. However, this is not true for applications where the shares are chosen based on the honest party’s secret state. Realizing this functionality requires to incorporate into it a secret state of the users. Unfortunately, our protocol cannot compute this functionality in a secure manner, as it must be that the composite generation and the biprimality test run together. Meaning, the parties only learn the composite if it is accepted by the biprimality test. 

For the sake of completeness we include a short description of [BF01] as adapted by [Gil99] for the twoparty setting. These protocols consist of the following three steps: 1) Each party Pi generates two random numbers pi and qi representing shares of p and q, such that p = ∑ i pi , q = ∑ i qi and p ≡ q ≡ 3 (mod 4). We note that [BF01] includes a distributed trial division of p and q for primes less than a bound B, which greatly improves the efficiency of the protocol. This trial division is not obtained by [Gil99], making our solution the first two party protocol achieving the significant speedup from trial division. 2) After having created the two candidates for being primes the parties execute a secure multiplication protocol to compute N = (p0 + p1)(q0 + q1). In [BF01] this step is based on standard generic solutions. Here we take a novel approach of utilizing both ElGamal and Paillier encryption schemes, giving us active security at a very low cost. Generating the RSA composite this way does not guarantee that the composite is made of uniformly random primes since the adversary can, in some limited way, influence the distribution of the primes. This issue was observed in [BF01] and discussed further below. 3) Finally, the candidate N for being an RSA composite is tested by a distributed biprimality test, which requires p ≡ q ≡ 3 (mod 4). If the biprimality test rejects N as being a proper RSA modulus, the protocol is restarted. 

Typically, the definition for the key generation algorithm requires that the RSA composite would be a product of two randomly chosen equal length primes p and q. However, in order to use the distributed biprimality test of Boneh and Franklin N must be a Blum integer (namely, N = pq, where p ≡ q ≡ 3 mod 4). Note that this is a common requirement for distributed biprimality tests and it does not decrease the security of the constructions that use these type of keys, since about 1/4 of all the RSA modulus are Blum integers. Moreover, as pointed out by [BF01], the parties can always influence the distribution of the most significant bit of each prime. This is because p and q are generated by adding shares over the integers which implies that they are not uniformly random, so that each party has some (limited) knowledge of the distribution based on its shares. 

We will therefore define a new public key generation algorithm, Gen′ , which captures this deviation and generates N by the same distribution as the protocol. This is obtained by Gen′ receiving additional two inputs rp and rq, representing potential adversary’s input shares. Gen′ adds this shares to some truly random chosen shares and ensures that the sum is congruent to 3 mod 4. Formally, let Gen′ (1n , rp, rq) denote a public key generation that takes two additional inputs besides the security parameter 1 n and works as follows: 

1. If rp, rq ≥ 2 n−2 output ⊥ and halt. 

2. Otherwise, choose a uniform random sp ∈ {0, 1} n−2 . 

3. Calculate p = 4(rp + sp) + 3 and examine the outcome: 

• if p is composite, then goto Step 2 and choose a new value for sp. 

• if p is prime, then repeat the process to generate q. 

4. Return N = pq, and generate the private key as in Gen. 

As proved by Boneh and Franklin, using Gen′ instead of Gen does not give the adversary the ability to factor N even if it can slightly influence its distribution. We formally state the security statement proven by [BF01], 

Lemma 4.1 (Revised [BF01, Lemma 2.1]) Suppose there exists a PPT algorithm B that chooses values (rp, rq) as above, then given N ← Gen′ (1n , rp, rq) and finally, factors N with probability at least 1/nd . Then there exists an expected polynomial time algorithm B ′ that factors a random RSA modulus with n-bit factors with probability at least 1/(27n d ). 

This lemma was originally stated for semi-honest adversaries but holds for the malicious case as well. We note that protocols with p and q being chosen as uniform random values do exist, however, they are significantly less efficient. Therefore, we choose to accept this nonuniform distribution induced by protocol DKeyGen and let the ideal functionality capture this deviation. Functionality FGEN formalizes this discussion. 

Functionality FGEN Key Generation: Upon receiving from party Pi a (Generate, 1 n) message, functionality FTHRES sends a message (RandInput) to the adversary and waits for the adversary to reply with (GenInput, ra, rb). FTHRES then invokes (pk, sk)←Gen′ (1n, ra, rb), records sk and sends pk to the adversary. If the adversary replies allow, the functionality sends pk to the parties, ignoring further messages of this form. Otherwise, it sends ⊥ to the honest party. 

Figure 1: The RSA Modulus Generation Functionality 

We are ready to describe our protocol which in addition to the above three steps includes a key-setup step used to generate keys for commitments and encryption schemes used in the protocol. Namely, a shared key is generated for the distributed additively homomorphic ElGamal encryption scheme and each party generates a key for standard non-distributive Paillier encryption and integer commitments. We observe that the reason for using both ElGamal and Paillier is due to efficiency considerations. Namely, most zeroknowledge proofs used here can be implemented in an efficient manner when applied on ElGamal (with a known group order), rather than on Paillier. Nevertheless, the plaintext cannot be recovered efficiently and therefore we use Paillier in a non-distributive fashion. In addition, the fact that a distributive ElGamal variant can be easily obtained allows us to design a the trial division test that is run on individual primes and improves the numbers of trials. In order to cope with malicious adversaries, our protocols employ zeroknowledge (ZK) proofs. Some of these proofs are known, others are new to this work and are interesting by themselves. We note that all the proofs that participate in Protocol 1 require a strict constant overhead. In Appendix 3 we specify these proofs in detail. 

Protocol 1 [DKeyGen] A distributed generation of an RSA composite with malicious security: 

• Inputs for parties P0, P1: A security parameter 1 n and a threshold B for the trial division. 1. Key-Setup. 

(a) The parties run protocol πGEN (cf. Section 2.2.2) for generating a public key pkEG = (g, h) and secret key shares sk0 EG and sk1 EG for ElGamal. 

(b) Each party Pi generates a Paillier key pair (pki Pa, ski Pa) with a modulus bit length of λ > 2n, and sends pki Pa = Ni Pa to the other party. Each party proves correctness of Ni Pa by πRSA (cf. Section 3). The Paillier keys are used for encryptions and commitments (cf. Sections 2.2.1, 2.3) 

2. Generate Candidates. 

(a) Generate Shares of Candidate. Each party Pi picks a random (n−2)-bit value p¯i , encrypts it and sends c¯i = EncpkEG (¯pi) to the other party. The parties prove knowledge of the plaintexts, via πENC, and prove that p¯i < 2 n−2 via πBOUND. In order to ensure that p0 ≡ 3 mod 4, the parties compute c0 ← (¯c0) 4 ·EncpkEG (3). Similarly, the parties ensure that p1 ≡ 0 mod 4 by c1 ← (¯c1) 4 . 

(b) Trial division. For all primes α ≤ B, the parties run trial division on p = p0 + p1. Each party Pi sends an encryption c (α) i = EncpkEG (pi mod α) to the other party, and proves the correctness of the computation using πMOD. 

The parties compute c (α) ← c (α) 0 · c (α) 1 and c˜ (α) ← c (α) · EncpkEG (−α). Clearly α divides p if and only if p (α) 0 + p (α) 1 ∈ {0, α}, i.e. when either c (α) or c˜ (α) is an encryption of zero. This is checked by raising these to secret, non-zero exponents and decrypting. If no prime α < B divides the candidate it is accepted by trial division. 

(c) Repeat. Repeat Steps 2a- 2b until two candidates p and q survive trial division. 

3. Compute Product (N = pq). 

(a) Compute the product. P0 sends P1 encryptions of p˜0 = p0 and q˜0 = q0 under pk0 Pa and proves knowledge of plaintexts using πENC. (Note that a malicious P0 may send encryptions of incorrect values). Next, P1 computes and sends: 

cN˜−p˜0q˜0 ← Encpk0 Pa (p0) q1 · Encpk0 Pa (q0) p1 · Encpk0 Pa (p1q1) = Encpk0 Pa ((p0 + p1)(q0 + q1) − p0q0) 

Furthermore, P1 proves that cN˜−p˜0q˜0 has been computed as a known linear combination based on Encpk0 Pa (˜p0) and Encpk0 Pa (˜q0) using πVERLIN. P0 decrypts, thus obtaining the plaintext mN˜−p˜0q˜0 ; from this N˜ = mN˜−p˜0q˜0 + ˜p0q˜0 is computed and sent to P1 along with an encryption cπ = Encpk0 Pa (˜p0q˜0). Finally, using πMULT and πZERO, P0 proves that cπ contains the product of the two original ciphertexts and that N˜ is the plaintext of 

cN˜−p˜0q˜0 cπ = Encpk0 Pa ((˜p0 + p1)(˜q0 + q1)). 

(b) Verify Multiplication. The parties use the homomorphic property of ElGamal encryption to compute an encryption of N = (p0 + p1)(q0 + q1) from the ciphertexts generated at Step 2a. The computation is analogous to that of Step 3a, again using πMULT for proving correct multiplication of (pi · qi) The parties use secure decryption of distributed ElGamal πDEC (cf. Section 2.2.2) to obtain g N , where both verify that g N˜ = g N , i.e. that N = N˜ and abort if equality does not hold. 

4. Biprimality Test. 

Execute biprimality test (cf. Section 4.1) and accept N if the test has accepted, otherwise the protocol is restarted from Step 2a. 

Theorem 7 Assuming hardness of the DDH and DCR problems, Protocol 1 realizes FGEN in the presence of malicious adversaries. 

A proof overview. Note that if both parties follow the protocol then a valid RSA modulus N is generated with high probability. Specifically, in the last iteration of the protocol two elements are chosen randomly and independently of previous generated candidates and are multiplied to produce N. By the correctness of the biprimality test specified below, N is a product of two primes with overwhelming probability. 

We assume the simulator has knowledge of the distribution of the loops in the protocol, from the protocol returning to step 2a when candidates are rejected. The simulator can simulate the distribution by running the protocol “in its head”, emulating the role of the honest party. Namely, denoting by Pi the corrupted party, then upon extracting A’s shares pi , qi , S picks two shares p1−i , q1−i as the honest party would do and checks whether NS = (pi + p1−i)(qi + q1−i) constitutes a valid RSA composite. If this is not the final iteration of the protocol, implied by the fact that NS is not a valid RSA composite, S uses p1−i , q1−i to perfectly emulate the role of the honest P1−i . If this is the final iteration, S asks the trusted party for FGEN to generate an RSA composite with pi , qi being the adversary’s input (as specified in Figure 1) and completes the execution by emulating the role of the honest party on arbitrary shares. The simulation is different for the two corruption cases as the parties’ role is not symmetric. For the case that P0 is corrupted, the simulator sends back in Step 3a the encryption of the composite returned from the trusted party and makes the ElGamal decryption decrypted into this composite as well. For the case that P1 is corrupted the simulator “decrypts” the Paillier ciphertext result into that composite and then makes the ElGamal decryption return the same outcome. 

In Step 3a, where the parties compute the product, we note that it is insufficient to let P1 complete the computation over the encrypted shares of P0 without verification of correctness. The problem is that P1 may attempt to compute N in a different, potentially failing way. Hence if it finds N, this may leak information. Although this issue does not seem critical for practical considerations we have to deal with it in order to obtain simulation based security. This makes this corruption case particular challenge since we had to show that an alternative computation in a successful execution implies determining the factors before the RSA-modulus is revealed. 

The complete proof is done by a series of games and is found in Appendix C.1. 

4.1 The Biprimality Test 

The distributed biprimality test for checking the validity of a candidate for being an RSA composite, is based on a test by Boneh-Franklin [BF01] where the parties first agree on a random element γ ∈ Z ∗ N with Jacobi symbol 1, and then raise γ to a power calculated from their shares. The test accepts a number with more than two prime factors with probability at most 1/2. Therefore, the parties must repeat this test sufficiently many times in order to decrease the error. We adopt this test for the malicious setting. We note that although the biprimality test by Damgard and Mikkelsen [DM10] has a better error estimate, it cannot be used efficiently ˚ in the two-party setting with malicious adversaries. In Appendix D we show how to adapt their test into the two-party setting when the parties are semi-honest. 

Protocol 2 [DPrim] A distributed biprimality test: 

• Inputs: A security parameter 1 n, a statistical parameter 1 ℓ and a public key candidate N. 

• The Protocol: 

1. The parties jointly generate a random element γ ∈ Z ∗ N with Jacobi symbol J (γ) = 1. By standard techniques this is made secure against active deviation. 

2. The parties compute the encryption e0 = EncpkEG ( N−(p0+q0)+1 4 ) using the homomorphic property of ElGamal (P1 knows the encryptions of p0 and q0 from the earlier protocol). Furthermore, P0 sends γ0 = γ ( N+1−(p0+q0) 4 ) mod N and proves consistency between e0 and γ0 using πEQ. 

3. P1 sends γ1 = γ ( −(p1+q1) 4 ) mod N to P0 and proves consistency using πEQ to an encryption e1 of −(p1+q1) 4 , computed as above. 

4. Finally, the parties reject N if and only if γ0 · γ1 mod N ̸= ±1. We further note that the test by [BF01] includes an additional step were instead of using γ, the parties randomly pick an element from the group (ZN [x]/(x 2 + 1))∗/Z ∗ N ; we omit the details due to the similarity of the above test. 

5. This test is repeated ℓ times to achieve sufficiently small error. 

Theorem 8 Assuming hardness of the DDH problem, Protocol 2 is a distributed Monte Carlo algorithm such that on a statistical parameter 1 ℓ and a random γ, it holds that 

• A correctly formed RSA modulus N = pq, where p ≡ q ≡ 3 (mod 4) is always accepted. 

• The average case probability of accept if either p or q is a composite, is at most 2 −ℓ . 

• The protocol is secure (simulatable with abort without knowledge of the factorization of N) in the presence of malicious adversaries. 

Correctness follows from [BF01]. Security is proven by simulation where the simulator is able to simulate the corrupted party’s view by having knowledge of the adversaries shares of p and q, and thereby being able to calculate γ0 or γ1, respectively. With this knowledge the simulator can simulate acceptance of a modulus without knowledge of the factorization. A complete proof can be found in Appendix C.2. 

5 A Complete Threshold Paillier Cryptosystem 

In the following section, we describe our threshold construction in the two-party setting for the Paillier encryption scheme [Pai99]. Our Threshold Paillier Scheme, TPS, is comprised of the following subprotocols: (i) The protocol DKeyGen (cf. Section 4) for distributed generation of an RSA composite. (ii) A protocol for distributed generation of the corresponding secret-key shares, denoted by Dsk (cf. Section 5.2). (iii) A protocol for distributed decryption, denoted by DDec, for decrypting according to Paillier’s specifications while maintaining the randomness of the ciphertext a secret (cf. Section 5.3). These protocols rely on the following standard hardness assumptions: (1) DDH (cf. Definition 1), due to employing the ElGamal scheme [ElG85], and (2) DCR (cf. Definition 2), due to employing the Paillier scheme [Pai99] and integer commitments [DN02, DN03]. 

Our protocols form the first complete threshold scheme for Paillier in the two-party setting with security in the presence of malicious adversaries under full simulation based definitions, following the ideal/real model paradigm We denote by Π = (Gen′ , Enc, Dec) the Paillier encryption scheme that is depicted in Section 2.2.1, with the modified key generation algorithm Gen′ specified in Section 4, encryption algorithm Enc and decryption algorithm Dec. The formal description of the threshold functionality, FTHRES is found in Figure 2. 

Theorem 9 Assuming hardness of the DDH and DCR problems, scheme TPS = (DKeyGen, Dsk, DDec) computes functionality FTHRES in the presence of malicious adversaries. 

Proof: The proof for this theorem follows from the proofs for Theorems 7, 8, 10 and 11. That is, Theorems 7 and 8 form a complete key generation protocol, where the parties compute an RSA composite without leaking its factorization. Moreover, Theorems 10 and 11 guarantee that the parties decrypt according to Paillier in a secure manner. 

Functionality FTHRES KEY GENERATION: Identical to KEY GENERATION in FGEN. DECRYPTION: Upon receiving a (Decrypt, c, Both) message from party Pi , FTHRES continues as follows: 1. If there exists a recorded secret key, then FTHRES forwards (Decrypt, c, Both) to party P1−i . (a) If P1−i replies with allow and Both = ϕ, FTHRES sends Decsk(c) only to Pi . Otherwise, if Both ̸= ϕ, FTHRES sends Decsk(c) to both parties. (b) If P1−i replies with disallow, then FTHRES forwards disallow to Pi . 2. If there does not exist a recorded secret key, functionality FTHRES sends disallow to Pi . 

Figure 2: The (Paillier) Threshold Functionality 

5.1 A Distributed Decryption for Paillier 

In this section we present a secure decryption protocol in the distributed setting. At first glance it may seem that decryption according to Paillier should follow the same outlines as decryption according to the RSA scheme, where the decrypter raises the ciphertext to the power of the inverse of N modulo ϕ(N) as e.g., in [CGHN01]. This is because for both schemes the public key is an RSA composite N and the secret key is the factorization of N, and both schemes share some similarities. Therefore, essentially one can apply for Paillier any distributed decryption protocol used for RSA. 

We observe that for some applications this type of algorithm is problematic. For instance, when decrypting as in RSA (i.e., raising the ciphertext to the inverse of N), the decrypter must extract the randomness used for computing the ciphertext first in order to complete the decryption. As desirable as this property may be it is problematic in the secure computation context, especially when simulation based security is required. This is due to the fact that it forces the simulator to present the randomness of the ciphertext instead of cheating by proving correctness of “decryption”, using ZK proofs. In addition we recall that by definition, Pallier’s scheme requires extra work in order to decrypt (on top of raising the ciphertext to the power of the secret value since the outcome from this computation is the plaintext multiplied with this secret value). This means that in the distributive setting, the parties must keep two types of shares in order to decrypt properly. When coping with malicious behavior it is not immediately clear how to efficiently verify the parties’ computations. Not even when using an RSA type decryption. As a side remark, we note that the protocol designed by Damgard and Jurik [DJ01] circumvents this technicality by having a trusted party pick ˚ a secret d ≡ 1 mod N ≡ 0 mod ϕ(N) which ensures that no leakage on the secret key. 

To the best of our knowledge, our protocol is the first that offers a distributive decryption for Paillier with simulation based security against malicious adversaries, so that the randomness is not extracted. It is comprised of the following two subprotocols: At first, the parties produce multiplicative shares (cf. Section 5.2). We note that this step is executed only once. Next, the parties run the distributed decryption algorithm using two types of shares (cf. Section 5.3). We further note that we successfully avoid ZK proofs for proving the correct computations of P1 and take a different approach. 

5.2 Computing Multiplicative Shares of the Secret Key 

In this section we describe our protocol for securely computing multiplicative shares of ϕ(N) −1 modulo N using two sets of shares. Note that the parties can, by local computations, calculate an additive sharing (skA 0 ,skA 1 ) of the private key, using values calculated in DKeyGen (cf. Section 4). However, for completing the decryption distributively in a secure manner they must compute an additional set of multiplicative shares (skM 0 ,skM 1 ) for ϕ(N), where the multiplication is computed in ZN . Informally, we rely on the fact that the parties already know additive shares of the secret key and use them in order to “decrypt” an encryption c of random message δ ∈R ZN , picked by party P0. Then, upon decrypting c, P1 learns [δ · ϕ(N)]−1 mod N, whereas P0 records δ. More formally, 

Protocol 3 [Dsk] A distributed secret key generation: 

• Inputs: A security parameter 1 n, a public key N and secret shares: p0, q0 for P0 and p1, q1 for P1. 

• The Protocol: 

1. Party P0 sets skA 0 = N − p0 − q0 + 1, whereas party P1 sets skA 1 = −(p1 + q1). 

2. Let N = pk, then P0 randomly picks δ ∈R Z ∗ N and sends P1 its encryption e = Encpk(δ) together with a proof of knowledge for δ via πENC. Moreover, P0 sends e ′ = e skA 0 mod N2 and proves that e ′ and γ 4 0 are consistent using πEQ (where γ0 is as computed in the biprimality test in Section 4.1). Finally, P0 records skM 0 = δ. 

3. P1 verifies the proof within πENC and aborts if it is invalid. Otherwise, it records the following value, 

skM 1 = ( e ′ · e skA 1 mod N2 − 1 N )−1 

where the computation of the inverse is performed in ZN . 

Correctness follows from the following: 

( e ′ · e skA 1 mod N2 − 1 N )−1 = ( Encpk(δ) ϕ(N) − 1 N )−1 = [δ · ϕ(N)]−1 mod N, 

Where the last equality follows from the correctness of the decryption of the Paillier. This implies that the parties multiplicatively share ϕ(N) −1 over ZN as required. 

Theorem 10 Assuming hardness of the DCR problem, Protocol 3 distributively generates multiplicative shares in the presence of malicious adversaries. 

Proof: The proof presented in the FENC, FEQ-hybrid model. Intuitively, when P1 is corrupted the simulator uses the knowledge of P1’s additive shares for p and q (extracted in the simulation of RSA key generation). The complete proof is found in Appendix C.3. 

5.3 A Complete Protocol for Decryption 

We are now ready to describe our protocol for a distributive decryption, denoted DDec. We assume that the parties are holding additively shares, denoted by skA 0 , skA 1 , as well as multiplicative shares (modulo the newly generated public key N), denoted by skM 0 , skM 1 . The protocol follows by having P0 randomizing the ciphertext they decrypt and then raise it to the power of its share. P1 completes the decryption by raising the result to the power of its share. In order to allow P0 to verify the computations performed by P1 we repeat this step twice and avoid using expensive ZK proofs. More specifically, P0 picks two random values, a and b, and computes the encryption of a · t + b where t is the plaintext from the first iteration (exploiting the homomorphism of Paillier). This, induces a one-time MAC on t. 

We continue with a formal description of our protocol. 

Protocol 4 A distributed decryption, DDec: 

• Joint Inputs: A security parameter 1 n, a public key N and a ciphertext c to be decrypted for P0. 

• Private Inputs: A pair of additive shares skA 0 , skA 1 (as generated in Section 4.1), and a pair of multiplicative shares skM 0 , skM 1 (as generated in Section 5.2) for P0 and P1, respectively. 

• The Protocol: 

1. Let pk = N, then P0 begins by randomly picking ω ∈R ZN and rω ∈R Z ∗ N , and sending P1, c ′ = Encpk(ω; rω) together with a zero-knowledge proof of knowledge for ω via πENC. 

2. Then, P0 sends c1 = (c · c ′ ) skA 0 mod N2 and proves this step using πEQ. 

3. If the zero-knowledge proof is verified correctly, P1 computes first c2 = (c · c ′ ) skA 1 mod N2 and then sends c3 = ((c1 · c2 − 1)/N) · skM 1 mod N. Otherwise it halts, aborting the protocol. 

4. P0 records m = (c3 · skM 0 ) − ω mod N. 

5. For the second run, P0 picks random elements a, b, r ∈ ZN and computes c ′′ = (c · c ′ ) a · Enc(b, r). Namely, P0 computes the encryption of a · ℓ + b, denoting a one-time MAC for ℓ, where ℓ = Decsk(c · c ′ ). P0 then proves its computations using a zero-knowledge proof, πEXP−RERAND. Next, the parties repeat Steps 2-4, using c ′′ instead of c · c ′ to compute c1 in Step 2. 

6. Denote by τ and τ ′ the respective outcomes of these computations. Then, in case τ ′ ̸= a· τ +b, P0 aborts the execution. Otherwise, it outputs τ − ω. 

7. In case both parties should learn the decryption of c as well, the parties repeat the above steps with reversed rolls. 

Denote by m = Decsk(c), where sk is the secret key ϕ(N) that corresponds to N. Then observe that c3 equals [(m + ω) · ϕ(N)] mod N. This is due to the facts that c · c ′ encrypts the plaintext m + ω and the parties raise it to the power of their additive shares. Then, by multiplying c3 with the multiplicative shares of ϕ(N), the outcome is m + ω. The same holds for the second iteration, where the parties repeat Steps 1-4 with a and b. We conclude that by the end of these two iterations P0 learns m + ω and a · (m + ω) + b so that the correctness of the check in Step 6 is followed from the security of the MAC. 

Theorem 11 Assuming hardness of the DCR problem, Protocol 4 distributively decrypt according to Paillier with security, realizes DECRYPTION in FTHRES, in the presence of malicious adversaries. 

Proof: The proof presented in the FENC, FEQ-hybrid model. The simulator is able to simulate by using the knowledge of the adversary’s shares of p and q extracted in the simulation of RSA key generation. The complete proof is found in Appendix C.4. 

6 The Efficiency of Our Protocols 

In this section we discuss the efficiency of our protocols. We split our discussion into two parts: a theoretic analysis with a focus on the asymptotic complexity, and a more practical analysis where we comment on optimizations which have been left out in order to make above presentation clearer. We remark that all of our zero-knowledge proofs run in constant rounds and require constant number of exponentiations – the only exception is πEQ, employed in our threshold decryption protocol, for which there is an amortized constant analysis due to Cramer and Damgard [CD09]. ˚ 

6.1 On the Number of Failed Attempts 

The complexity of our protocol depends heavily on the number of failed attempts at generating the modulus. Without running a trial division the protocol has to restart with two freshly generated prime candidates after every rejected composite; or otherwise the leaked information would make factoring an accepted composite easy. Without trial division the expected number of tests is given by the probability of choosing two random primes simultaneously. This can be calculated by the Prime Number Theorem, making the expected number of executions: 512 bit primes: ( ln(2512)/2 )2 ≈ 31000, 1024 bit primes: ( ln(21024)/2 )2 ≈ 126000. 

Nevertheless, this can be dramatically improved when employing the trial division test. Following the analysis of [BF01] it can be shown that the probability a generated composite is a prime, given that it passes the trial division, is computed due to [DeB] and is as follows, 

Pr[p is prime | p passes trial division with threshold B] = 2.57 · ln B n ( 1 + o ( 1 n )) 

which for ln B = 9 (i.e., B = 8103) and n = 512 is approximately 1/22, and for n = 1024 is 1/44. This means that our protocol needs to test an expected number of 484 candidates when n = 512, and 1936 candidates if n = 1024. This shows how important our trial division is for the efficiency of the protocol, which is the first to incorporate this test securely in the two-party setting. We remark that this analysis is independent of the construction used for generating the composite and strictly relies on the primes density in a given interval. 

6.2 Theoretic Efficiency 

Key Generation. Ignoring the initial key-setup, the complexity of a single RSA-composite-generation attempt (except for the biprimality test) is dominated by the number of trial divisions; the rest of the secure computation requires only constant work and communication. Each of the trial divisions require only  constantly many invocations of sub-protocols, including πMOD (and hence of πBOUND) and all these subprotocols require only a constant number of exponentiations. Thus, we conclude that the total costs that are incurred by the entire protocol are linear in the number of trial divisions. Further, all sub-protocols at every step of the full protocol may be run in parallel, hence round complexity is constant. 

Biprimality Test. The main part of the biprimality test consists of the verification of the secure exponentiation of the random γ. Further, in the test of [BF01], the parties reach a negligible error probability by repeating the test ℓ times – as the test has one-sided error with probability at most 1/2, it must be run e.g. 40 times in order to achieve an error of 2 −40. The most expensive part of the test is the execution of πEQ as it is a cut and choose protocol, i.e. we need O(ℓ) exponentiations overall for each run, where ℓ is some statistical security parameter. However, as noted above this may be brought down to amortized constant overhead using the techniques of Cramer and Damgard [CD09]. Further, as the all ˚ ℓ tests may be run in parallel, round complexity is constant as well. 

Secret-Key Shares. The generation of the multiplicative key shares requires an invocation of πEQ, hence complexity is not constant due to the use of cut and choose. However, this is a one-time execution in the generation of the secret key, hence the cost can be amortized over an arbitrary number of subsequent decryptions. 

Threshold Decryption. This protocol is dominated by the invocation of πEQ. However, in a real-world scenario we expect to be decrypting a large number of cipher texts, e.g. as part of performing multiple concurrent, [CDN01]-based multiplications. As in the biprimality test, the amortized cost of this can be improved to constant using [CD09]. 

6.3 Practical Considerations 

To ease the security proof, we have taken a pessimistic approach above. Namely, zero-knowledge proofs have been applied at all stages in order to catch cheating players at once. However, a more optimistic approach allows for a more efficient protocol: All but one of our RSA-composite-generation attempts fail, and most of the zero-knowledge proofs are only needed for the successful modulus generation – hence they may be postponed. In addition to this, further optimizations for distributed RSA key generation are possible. We refer to Boneh and Franklin [BF01] for a list of general optimizations some of which are also applicable in our setting. 

For the failing RSA-composite-generation attempts, we utilize the fact that the encryptions provided can be viewed as binding commitments. On failure, the parties reveal all random choices, thereby allowing the other party to verify their correct behavior by “executing” the protocol “in their head” and checking the correctness of the other party’s messages, e.g. that plaintexts are appropriately bounded. Thus, overall efficiency of the many failing attempts will not be much more costly than twice that of failing attempts for the passively secure protocol. Once an attempt succeeds, ZK-proofs are used to ensure that this was correct. Slightly more formally, the key idea is that the simulator must know that the adversary is cheating (and that an honest party would detect this later, i.e. that the invocation should fail). We cannot simply postpone all proofs; care must be taken to allow simulation and to not reveal information that would allow a malicious party to, e.g., fake some zero-knowledge proof at a later point. 

Generating the prime candidate. We may omit the invocations of πBOUND on pi and qi , as this statement is implicitly shown by the invocations of πMOD in the trial divisions. Further, verification may be postponed until we believe we have successfully generated an RSA-modulus; we cannot ensure correctness underway, but the encryption will be the same, thus, we still accept or reject as if we had run πBOUND immediately. 

Trial division. We may postpone the invocations of πMOD at the cost of a few extra executions of simple proofs of knowledge, such as πENC. This ensures that the party knows its input, and that the simulator knows whether a later invocation of πMOD may be successful (as it knows both what the input should be and what it actually is). If a trial division fails incorrectly, the honest party learns this when the corrupt party reveals its random choice, including its share of the random prime and the reduction modulo the trial-division-prime. If a trial division succeeds incorrectly, this can be discovered easily by performing the same trial-division on N – indeed at this point we may use a larger bound for the trial division as this can be performed very efficiently on the public N. The only remaining possibility is the case where the test should succeed, and did so despite one party providing an incorrect input. This case is handled by executing πMOD for each trial division once the biprimality test succeeds, at which point the honest party will detect the incorrect behavior. 

Computing and verifying the product. For the Paillier computation, we may postpone all checks except the proof that N˜ was the plaintext of the encryption supplied by P1. Privacy of P0 follows from the semantic security of Paillier encryption, while privacy for P1 follows from the fact the encryption sent back by P1 only contains the desired result. Leakage from constructing a potentially incorrect value is eliminated by the eventual execution of the full zero-knowledge proofs. Alternatively, we may avoid verifying the product altogether. This may leak a single bit of information, namely whether some function on the shares of the honest party equals the still hidden modulus, N. Depending on the setting, this leakage may or may not be acceptable. 

Biprimality test. The invocation of πEQ can be postponed. If the test fails, the parties simply reveal their shares of the candidates; both parties may then verify that the other performed the exponentiations correctly. On the other hand, if the test succeeds, the parties have either determined an RSA composite or one of them has cheated. They now execute πEQ to determine which of the two is the case. Since the simulator knows the shares of the corrupt party, it is straightforward for it to check if the value supplied is the correct one. 

References [ACS02] Joy Algesheimer, Jan Camenisch, and Victor Shoup. Efficient computation modulo a shared secret with application to the generation of shared safe-prime products. In Moti Yung, editor, CRYPTO, volume 2442 of Lecture Notes in Computer Science, pages 417–432. Springer, 2002. [BB89] J. Bar-Ilan and D. Beaver. Non-cryptographic fault-tolerant computing in a constant number of rounds of interaction. In Piotr Rudnicki, editor, Proceedings of the eighth annual ACM Symposium on Principles of distributed computing, pages 201–209, New York, 1989. ACM Press. [BBBG] Simon Blackburn, Simon Blake-Wilson, Mike Burmester, and Steven Galbraith. Shared generation of shared RSA keys. http://cacr.math.uwaterloo.ca/techreports/1998/corr98-19.ps. [BDOZ11] Rikke Bendlin, Ivan Damgard, Claudio Orlandi, and Sarah Zakarias. Semi-homomorphic en- ˚ cryption and multiparty computation. In Kenneth G. Paterson, editor, EUROCRYPT, volume 6632 of Lecture Notes in Computer Science, pages 169–188. Springer, 2011. [BF01] Dan Boneh and Matthew K. Franklin. Efficient generation of shared RSA keys. J. ACM, 48(4):702–722, 2001. [BFP+01] O. Baudron, P. A. Fouque, D. Pointcheval, G. Poupard, and J. Stern. Practical multi-candidate election system. In In PODC, pages 274–283. ACM Press, 2001. [Bou00] Fabrice Boudot. Efficient proofs that a committed number lies in an interval. In Bart Preneel, editor, EUROCRYPT, volume 1807 of Lecture Notes in Computer Science, pages 431–444. Springer, 2000. 21 [CD09] Ronald Cramer and Ivan Damgard. On the amortized complexity of zero-knowledge protocols. ˚ In Shai Halevi, editor, CRYPTO, volume 5677 of Lecture Notes in Computer Science, pages 177–191. Springer, 2009. [CDN01] Ronald Cramer, Ivan Damgard, and Jesper Buus Nielsen. Multiparty computation from thresh- ˚ old homomorphic encryption. In Birgit Pfitzmann, editor, EUROCRYPT, volume 2045 of Lecture Notes in Computer Science, pages 280–299. Springer, 2001. [CGHN01] Dario Catalano, Rosario Gennaro, Nick Howgrave-Graham, and Phong Q. Nguyen. Paillier’s cryptosystem revisited. In ACM Conference on Computer and Communications Security, pages 206–214, 2001. [CGS97] R. Cramer, R. Gennaro, and B. Schoenmakers. A secure and optimally efficient multi-authority election scheme. In EUROCRYPT, pages 103–118, 1997. [CKY09] Jan Camenisch, Aggelos Kiayias, and Moti Yung. On the portability of generalized schnorr proofs. In EUROCRYPT 2009, pages 425–442, 2009. [Cle86] Richard Cleve. Limits on the security of coin flips when half the processors are faulty (extended abstract). In STOC, pages 364–369. ACM, 1986. [Coc97] C Cocks. Split generation of RSA parameters with multiple participants. In Proceedings of 6th IMA conference on Cryptography and Coding, pages 200–212. LNCS 1355, 1997. [Cop97] Don Coppersmith. Small Exponents to Polynomial Equations, and Low Exponent RSA Vulnerabilities. Journal of Cryptology, 10:233–260, 1997. [CP92] D. Chaum and T. Pedersen. Wallet databases with observers. In CRYPTO, pages 89–105, 1992. [DeB] N. DeBruijn. On the number of uncanceled elements in the sieve of eratosthenes. In In Proc. Neder. Akad. Wetensh., (53),, pages 803–812. (Reviewed in LeVeque Reviews in Number Theory, 4, N-28, page 221). [Des94] Y. G. Desmedt. Threshold cryptography. European Transactions on Telecommunications, 5(4):449–457, July 1994. [DF02] Ivan Damgard and Eiichiro Fujisaki. A statistically-hiding integer commitment scheme based ˚ on groups with hidden order. In ASIACRYPT, pages 125–142, 2002. [DH76] W. Diffie and M. E. Hellman. New Directions in Cryptography. IEEE Transactions on Information Theory, 22(6):644–654, 1976. [DJ01] Ivan Damgard and Mads Jurik. A generalisation, a simplification and some applications of ˚ paillier’s probabilistic public-key system. In Kwangjo Kim, editor, Public Key Cryptography, volume 1992 of Lecture Notes in Computer Science, pages 119–136. Springer, 2001. [DJ02] Ivan Damgard and Mads Jurik. Client/server tradeoffs for online elections. In David Nac- ˚ cache and Pascal Paillier, editors, Public Key Cryptography, volume 2274 of Lecture Notes in Computer Science, pages 125–140. Springer, 2002. [DM10] Ivan Damgard and Gert Læssøe Mikkelsen. Efficient, robust and constant-round distributed ˚ RSA key generation. In Daniele Micciancio, editor, TCC, volume 5978 of Lecture Notes in Computer Science, pages 183–200. Springer, 2010. 22 [DN02] Ivan Damgard and Jesper Buus Nielsen. Perfect hiding and perfect binding universally com- ˚ posable commitment schemes with constant expansion factor. In CRYPTO, pages 581–596, 2002. [DN03] Ivan Damgard and Jesper Buus Nielsen. Universally composable efficient multiparty computa- ˚ tion from threshold homomorphic encryption. In Dan Boneh, editor, CRYPTO, volume 2729 of Lecture Notes in Computer Science, pages 247–264. Springer, 2003. [ElG85] T. ElGamal. A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. IEEE Trans. Info. Theory, IT 31:469–472, 1985. [FFS88] Uriel Feige, Amos Fiat, and Adi Shamir. Zero-knowledge proofs of identity. J. Cryptology, 1(2):77–94, 1988. [FMY98] Yair Frankel, Philip D. Mackenzie, and Moti Yung. Robust efficient distributed RSA-key generation. In stoc98, pages 663–672. ACM Press, 1998. [FO97] Eiichiro Fujisaki and Tatsuaki Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In Burton S. Kaliski Jr., editor, CRYPTO, volume 1294 of Lecture Notes in Computer Science, pages 16–30. Springer, 1997. [FPS00] P.A. Fouque, Guillaume Poupard, and Jacques Stern. Decryption in the context of voting or lotteries. In Financial Crypto ’00. Springer-Verlag, 2000. [FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, pages 186–194, 1986. [Gil99] Niv Gilboa. Two party RSA key generation. In Michael J. Wiener, editor, CRYPTO, volume 1666 of Lecture Notes in Computer Science, pages 116–129. Springer, 1999. [GJKR01] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Robust Threshold DSS Signatures. Information and Computation, 164(1):54–84, 2001. [GJKR07] R. Gennaro, Stanislaw Jarecki, H. Krawczyk, and T. Rabin. Secure Distributed Key Generation for Discrete-Log Based Cryptosystems. Journal of Cryptology, 20(1):51–83, 2007. [GKR00] R. Gennaro, H. Krawczyk, and T. Rabin. Robust and Efficient Sharing of RSA Functions. Journal of Cryptology, 13(2):273–300, 2000. [Gol04] Oded Goldreich. Foundations of Cryptography: Volume 2. Cambridge University Press, 2004. Preliminary version http://philby.ucsd.edu/cryptolib.html/. [HT10] Carmit Hazay and Tomas Toft. Computationally secure pattern matching in the presence of malicious adversaries. In To appear ASIACRYPT, 2010. [IPS09] Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. Secure arithmetic computation with no honest majority. In Omer Reingold, editor, TCC, volume 5444 of Lecture Notes in Computer Science, pages 294–314. Springer, 2009. [JL09] Stanislaw Jarecki and Xiaomin Liu. Efficient oblivious pseudorandom function with applications to adaptive ot and secure computation of set intersection. In TCC, pages 577–594, 2009. 23 [JS07] Stanislaw Jarecki and Vitaly Shmatikov. Efficient two-party secure computation on committed inputs. In Moni Naor, editor, EUROCRYPT, volume 4515 of Lecture Notes in Computer Science, pages 97–114. Springer, 2007. [KS08] Kamer Kaya and Ali Aydin Selc¸uk. Robust threshold schemes based on the chinese remainder theorem. In Serge Vaudenay, editor, AFRICACRYPT, volume 5023 of Lecture Notes in Computer Science, pages 94–108. Springer, 2008. [Lip03] Helger Lipmaa. On diophantine complexity and statistical zero-knowledge arguments. In ChiSung Laih, editor, ASIACRYPT, volume 2894 of Lecture Notes in Computer Science, pages 398–415. Springer, 2003. [LP10] Y. Lindell and B. Pinkas. Secure Two-Party Computation via Cut-and-Choose Oblivious Transfer. In eprint, http://eprint.iacr.org/2010/284, 2010. [Pai99] Pascal Paillier. Public-key cryptosystems based on composite degree residuosity classes. In EUROCRYPT, pages 223–238, 1999. [PS98] Guillaume Poupard and Jacques Stern. Generation of shared RSA keys by two parties. In in Asiacrypt98, pages 11–24. Springer-Verlag, 1998. [Rab80] M. Rabin. Probabilistic Algorithm for Testing Primality. Journal of Number Theory, 12:128– 138, 1980. [Rab81] Michael O. Rabin. How To exchange Secrets with Oblivious Transfer. Techincal Report TR-81, Aiken Computation Lab, Harvard University, 1981. [Rab98] Tal Rabin. A simplified approach to threshold and proactive rsa. In CRYPTO, pages 89–104, 1998. [Sch91] C. P. Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4:161–174, 1991. [Sho00] V. Shoup. Practical threshold signatures. In EUROCRYPT, pages 207–220, 2000. A Distributed Generation an RSA Composite [PS98] In [PS98], Poupard and Stern suggested a protocol that enables two parties to generate an RSA composite without the help of a trusted dealer. In particular, they showed how to evaluate any algebraic expression as follows: Let λ0 and λ1 denote the respective inputs of P0 and P1 sampled out of a polynomially bounded domain Λ, and let f denotes the public function that the parties wish to compute. Then, party P0 chooses two random values α, β from a predetermined set and computes α · f(λ0, λ) + β for all λ ∈ Λ. Next, the parties run an oblivious transfer protocol [Rab81] where P0 enters the above set and P1 enters its input λ1 to f. Upon completing this execution, P1 learns y1 = α · f(λ0, λ1) + β. The parties repeat the above with reversed roles. Denote by y0 = α ′ · f(λ0, λ1) + β ′ , P0’s output from the later oblivious transfer execution. Then, in the final step, the parties reveal (α, β, y0) and (α ′ , β′ , y1) simultaneously and verify their outputs. This protocol can be utilized to compute N = (p0 + p1)(q0 + q1), where party P0 enters two random shares denoted by p0, q0 and P1 enters its random shares, p1, q1. Nevertheless, the fact that it incurs linear costs in the size of the domain makes it impractical for super polynomial domains, as in most cases. In order to circumvent this problem, Poupard and Stern introduce the following solution. The parties agree first on M, as the smallest product of prime numbers greater than 2 n and compute the function in ZM. Now, 24 since M can be factored into smaller, relatively prime factors, the parties run the protocol for each prime factor mi of M and then use the Chinese Remainder Theorem to combine these outcomes into the desired computation modulus M. Apart from the fact that the paper does not introduce a complete simulation based proof, this technique induces a problem when coping with malicious activity, as the protocol does not have a mechanism which verifies that the parties indeed use consistent inputs either for the multiple oblivious transfer executions, or even for a single invocation as in the original construction. In particular, it is not clear how to build such a practical mechanism. In addition, the efficiency of the later protocol still relies on the number of integers in the primes factorization of M and the sizes of the domains that they induce. B Security in the Presence of Malicious Adversaries In this section we briefly present the standard definition for secure multiparty computation and refer to [Gol04, Chapter 7] for more details and motivating discussion. Two-party computation. A two-party protocol problem is cast by specifying a random process that maps pairs of inputs to pairs of outputs (one for each party). We refer to such a process as a functionality and denote it f : {0, 1} ∗ × {0, 1} ∗ → {0, 1} ∗ × {0, 1} ∗ , where f = (f1, f2). That is, for every pair of inputs (x, y), the output-vector is a random variable (f1(x, y), f2(x, y) ranging over pairs of strings where P0 receives f1(x, y) and P1 receives f2(x, y). We sometimes denote such a functionality by (x, y) 7→ (f1(x, y), f2(x, y)). Thus, for example, the oblivious transfer functionality is denoted by ((x0, x1), σ) 7→ (λ, xσ), where (x0, x1) is the first party’s input, σ is the second party’s input, and λ denotes the empty string (meaning that the first party has no output). Adversarial behavior. Loosely speaking, the aim of a secure multiparty protocol is to protect honest parties against dishonest behavior by other parties. In this section, we outline the definition for malicious adversaries who control some subset of the parties and may instruct them to arbitrarily deviate from the specified protocol. We also consider static corruptions, meaning that the set of corrupted parties is fixed at the onset. Security of protocols (informal). The security of a protocol is analyzed by comparing what an adversary can do in a real protocol execution to what it can do in an ideal scenario that is secure by definition. This is formalized by considering an ideal computation involving an incorruptible trusted third party to whom the parties send their inputs. The trusted party computes the functionality on the inputs and returns to each party its respective output. Loosely speaking, a protocol is secure if any adversary interacting in the real protocol (where no trusted third party exists) can do no more harm than if it was involved in the above-described ideal computation. One technical detail that arises when considering the setting of no honest majority is that it is impossible to achieve fairness or guaranteed output delivery [Cle86]. That is, it is possible for the adversary to prevent the honest party from receiving outputs. Furthermore, it may even be possible for the adversary to receive output while the honest party does not. We consider malicious adversaries and static corruptions in this paper. Execution in the ideal model. In an ideal execution, the parties send their inputs to the trusted party who computes the output. An honest party just sends the input that it received whereas a corrupted party can replace its input with any other value of the same length. Since we do not consider fairness, the trusted party first sends the output of the corrupted parties to the adversary, and the adversary then decides whether the honest parties receive their (correct) outputs or an abort symbol ⊥. Let f be a two-party functionality where f = (f1, f2), let A be a non-uniform probabilistic polynomial-time machine, and let I ⊆ [2] be the set of 25 corrupted parties (either P0 is corrupted or P1 is corrupted or neither). Then, the ideal execution of f on inputs (x, y), auxiliary input z to A and security parameter n, denoted IDEALf,A(z),I (x, y, n), is defined as the output pair of the honest party and the adversary A from the above ideal execution. Execution in the real model. In the real model there is no trusted third party and the parties interact directly. The adversary A sends all messages in place of the the corrupted party, and may follow an arbitrary polynomial-time strategy. In contrast, the honest parties follow the instructions of the specified protocol π. Let f be as above and let π be a two-party protocol for computing f. Furthermore, let A be a nonuniform probabilistic polynomial-time machine and let I be the set of corrupted parties. Then, the real execution of π on inputs (x, y), auxiliary input z to A and security parameter n, denoted REALπ,A(z),I (x, y, n), is defined as the output vector of the honest parties and the adversary A from the real execution of π. Security as emulation of a real execution in the ideal model. Having defined the ideal and real models, we can now define security of protocols. Loosely speaking, the definition asserts that a secure party protocol (in the real model) emulates the ideal model (in which a trusted party exists). This is formulated by saying that adversaries in the ideal model are able to simulate executions of the real-model protocol. Definition 12 Let f and π be as above. Protocol π is said to securely compute f with abort in the presence of malicious adversaries if for every non-uniform probabilistic polynomial-time adversary A for the real model, there exists a non-uniform probabilistic polynomial-time adversary S for the ideal model, such that for every I ⊆ [2], { IDEALf,S(z),I (x, y, n) } x,y,z∈{0,1} ∗ ,n∈N c ≡ { REALπ,A(z),I (x, y, n) } x,y,z∈{0,1} ∗ ,n∈N where |x| = |y|. Reactive functionalities. Until now we have considered the secure computation of simple functionalities that compute a single pair of outputs from a single pair of inputs. However, not all computations are of this type. Rather, many computations have multiple rounds of inputs and outputs. Furthermore, the input of a party in a given round may depend on its output from previous rounds, and the outputs of that round may depend on the inputs provided by the parties in some or all of the previous rounds. In the context of secure computation, multi-phase computations are typically called reactive functionalities. Such functionalities can be modeled as a series of functions (f 1 , f 2 , . . .) where each function receives some state information and two new inputs. That is, the input to function f j consists of the inputs (xj , yj ) of the parties in this phase, along with a state input σj−1 output by f j−1 . Then, the output of f j is defined to be a pair of outputs f j 1 (xj , yj , σj−1) for P1 and f j 2 (xj , yj , σj−1) for P2, and a state string σj to be input into f j+1. We stress that the parties receive only their private outputs, and in particular do not receive any of the state information; in the ideal model this is stored by the trusted party. C Omitted Proofs C.1 A proof of Theorem 7 for Securely Generating an RSA Composite Proof: The proof is shown in a hybrid model, where a trusted party replaces the protocols πGEN, πENC, πMOD, πVERLIN, πMULT, πZERO, πDEC and DPrim. We assume the simulator S has knowledge of the distribution of the loops in the protocol, from the protocol returning to step 2a when candidates are rejected. The simulator can simulate the distribution by running the protocol “in its head”, emulating the role of the 26 honest party. Namely, denoting by Pi the corrupted party, then upon extracting A’s shares pi , qi , S picks two shares p1−i , q1−i as the honest party would do and checks whether NS = (pi + p1−i)(qi + q1−i) constitutes a valid RSA composite. If this is not the final iteration of the protocol, implied by the fact that NS is not a valid RSA composite, S uses p1−i , q1−i to perfectly emulate the role of the honest P1−i . If this is the final iteration, S asks the trusted party for FTRES to generate an RSA composite with pi , qi being the adversary’s input (as specified in Figure 2) and completes the execution as follows. We distinguish between corruption of P0 and P1. P0 is corrupted. Let A denote an adversary controlling party P0. Then, construct a simulator S simulating the view of the adversary as follows. 1. KEY-SETUP. (a) S emulates the trusted party FGEN by generating an ElGamal key pair (pkEG, skEG), sharing skEG to skS EG and skA EG and handing pkEG and skA EG to A. (b) S generates a Paillier key pair (pkS Pa, skS Pa) as described, sends pkS Pa to A, and receives a key pkA Pa from A. πRSA is executed to verify that the Paillier keys are well formed. 2. GENERATE CANDIDATES. (a) GENERATE SHARES OF CANDIDATE. S uses 0 for p˜S, encrypts it and sends c˜S = EncpkEG (0) to A, and receives c˜A from A. S emulates the trusted party for FENC, receiving pA and the randomness used as witness and verifying c˜A. If the verification fails S halts. S stores the share pA. πBOUND is executed where S once plays the role of the verifier and once the role of the prover (note that 0 meets the bound requirement made in Step 2a of the protocol). In order to ensure that p0 ≡ 3 mod 4, the parties compute c0 ← (˜c0) 4 · EncpkEG (3). Similarly, the parties ensure that p1 ≡ 0 mod 4 by c1 ← (˜c1) 4 . (b) TRIAL DIVISION. For primes α ≤ B, S sends an encryption c (α) S = EncpkEG (0) to A, and receives c (α) A from A. Ideal execution of FMOD is emulated, by S receiving the randomness used for encrypting c (α) A as witness, and verifying it contains the correct value, and as accepting. S and A each compute c (α) ← c (α) A · c (α) S and c˜ (α) ← c (α) · EncpkEG (−α), and raising these to secret, non-zero exponents. S simulates decrypting, by emulating the output of FDEC to be either zero or a random nonzero element in the plaintext space. A nonzero element is output when trial division by α should succeed, and zero is the output when trial division should fail. This is simulated according to the distribution of the execution. (c) REPEAT. Repeat step 2a and 2b according to the distribution of execution. 3. COMPUTE PRODUCT (N = pq). (a) COMPUTE THE PRODUCT. S sends p0 and q0 to FTHRES and receives an RSA composite N from FTHRES. If A does not deviate and sends proper encryptions of p0, q0, S simulates cN˜−p˜0q˜0 ← Encpk0 Pa (N − p0q0) and emulates FVERLIN as accepting. S then receives N˜ and cπ from A and emulates FMULT and FZERO by receiving the witnesses and verifying the statements. If the conditions for accepting are not met, S halts, aborting the execution. If A does not send proper encryptions of p0, q0, S uses p1, q1, picked at the outset of this iteration, for completing the execution. (Note that NS = (p0 + p1)(q0 + q1) form a valid RSA 27 composite. Looking a head, this would imply that the decryption of cN˜−p˜0q˜0 is identically distributed in both the simulated and hybrid executions since in both cases the adversary sees some information of shares picked as the honest P1 would). (b) VERIFY MULTIPLICATION. S simulates the computation of the encrypted N by running the protocol as specified and emulating FMULT twice; once by receiving the witness and verifying the statement, and once by emulating an accepting answer for verifying the honest P1’s computations. If A did not deviate in step 3a, then S emulates ideal execution for FDEC as outputting g N = g N˜ where N is the composite returned by FTHRES. If A deviated in step 3a, then S emulates FDEC as outputting g NS ̸= g N˜ , and aborting the protocol. 4. BIPRIMALITY TEST. Simulate DPrim as either accepting or rejecting according to the distribution of the protocol run, which can be done by Theorem 8. Clearly S runs in expected polynomial time, it is left to prove indistinguishability of the simulation in the ideal world and the hybrid execution of the protocol. This will be done by a series of games. Game H0. This game corresponds to the original simulation. Game H1. In this game there is no functionality FTHRES. Instead, simulator S1 generates the RSA modulus N by itself the same way FTHRES does it. This means S1 knows the factorization of N. Furthermore, S1 plays the exact same role as S. H1 is clearly perfectly indistinguishable from H0. Game H2. Simulator S2 does not know the secret ElGamal key. That is, instead of emulating FGEN in step 1a, S2 receives pkEG from an oracle, generates a random share as skA EG and hands pkEG and skA EG to A. Since S1 does not use its knowledge of skEG, and since skA EG can be simulated statistically close to the real value. H2 is statistically indistinguishable from H1. Game H3. In this game simulator S3 uses N instead of NS in case A deviates in Step 3a of the simulation above. Then, the only difference between the views of games H2 and H3 is with respect to this step. However, since the rest of the messages computed by S2 and S3 are independent of these composites. The adversary’s view is identically distributed in both games. Game H4. In this game simulator S4 does not simulate the ElGamal ciphertexts by sending encryptions of 0, rather it sends encryptions of the real shares that yield the right RSA composite N. More specifically, since S4 extracts the shares p0, q0 of A and since S4 generates N by itself it can compute shares p1, q1 such that N = (p0 + p1)(q0 + q1), and simulate the execution resulting in an accepted N. H4 is computationally indistinguishable from H3 which can be proven by a reduction to the sematic security of ElGamal (according to semantic security game specified in Definition 4). More formally, the reduction goes as follows: We assume the existence of an distinguisher D3−4 capable of distinguishing H3 from H4 with more than negligible probability. We now construct an adversary AEG for breaking the semantic security of the ElGamal encryption scheme. AEG follows S4’s instructions, except instead of encrypting values with the pkEG it asks an oracle to encrypt either m0 = 0 or m1 being the real share that yields a proper prime. AEG completes the execution of D3−4 as in game H4. If D3−4 guesses H3 as being executed, then AEG outputs 0, if D3−4 guesses H3 as being executed, then AEG outputs 1. 28 Game H5 In this game simulator S5 does not extract the shares of the candidates for being primes from A. Instead, S5 generates the shares as the honest P1 does in the hybrid execution. This implies that the only difference in A’s view within executions H4 and H5 is with respect to step 3b of the simulation above, where S4 makes the protocol abort if A deviates in step 3a by not sending proper encryptions of p0, q0. Note that there are two cases here: 1) A deviates by sending encryptions of values different than p0 and q0, which leads to a different composite than the one computed using the ElGamal encryptions in Step 2a of the simulation. 2) A deviates by sending encryptions of values different than p0 and q0, which leads to a the same composite than the one computed using the ElGamal encryptions in Step 2a. Focusing on (1), we note that the adversary always sees the same view in both games, since in both cases it sees some information of the real shares picked by P1 that correspond to N. As for (2), we note that as described in appendix C.1.1, honest P1 always detects such a cheating, implying that H4 is statistically close to H5. Finally, since H5 corresponds to executing the real protocol in the hybrid model, we conclude that if P0 is corrupted then the real execution and the ideal world are computationally indistinguishable. P1 is corrupted. Let A denote an adversary controlling party P1. Then, construct a simulator S as follows. All steps except step 3a are analog to the previous simulation. 3. COMPUTE PRODUCT. (N = pq) (a) COMPUTE THE PRODUCT. S simulates the encryptions of p˜0 and q˜0 as encryptions of 0 under pkS Pa and emulates FENC, as accepting. S receives cN˜−p˜0q˜0 from A and during emulation of FVERLIN, S extracts the values p1 q1 and p1q1, and if these values are not consistent with the values extracted in step 2a, then S continues simulating the protocol using NS and p0, q0. If A does not deviate, S sends encryption of N˜ = N to A along with an encryption cπ = Encpk0 Pa (0) and emulates FMULT and FZERO as accepting. Clearly S runs in expected polynomial time, it is left to prove indistinguishability of the simulation in the ideal world and the real execution of the protocol. This will be done by a series of games. Game H0 - H4. These games are identical to H0 - H4 in the case of corruption of P0 Game H5. In this game simulator S5 does not simulate the Paillier encryptions by encryptions of 0. Instead, it sends the encryption of p0q0. We claim that H4 and H5 are computationally indistinguishable. The proof is completely analog to the indistinguishability of H3 and H4. Game H6. In this game simulator S6 does not extract the shares of the candidates for being primes from A in step 2a and step 3a. Instead, S6 generates the shares as the honest P0 does in the hybrid execution. Recall that in the previous game S5 makes the protocol abort in step 3b if A deviates in step 3a, however, as described in appendix C.1.1 this will also be the case in this game. Therefore, we have that H5 and H6 are statistically close. Since H6 corresponds to executing the real protocol in the hybrid model, we conclude that if P0 is corrupted then the real execution and the ideal world is computationally indistinguishable. 29 C.1.1 Deviation while Computing N˜ is Always Detected The ZK proofs used in the calculation of N˜ in Step 3a in Protocol 1 ensure that the parties compute N˜ based on values they know, but not that the correct pi and qi are used for this computation. More specifically, this step ensures that N˜ ≡ N mod N0, where N0 is the Paillier key picked by P0. However, this does not rule out from a malicious party, A, supplying wrong values but still getting the right result. For instance, A can guess the difference δ between p and q and switch the factors around by using pi + δ and qi − δ instead of pi and qi , respectively. Now, since we have that p0 + p1 + δ = q, q0 + q1 − δ = p the product of pi + δ and qi − δ still equals N. Intuitively, this specific attack is infeasible, however, we must rule out all such attacks. A much worse attack would be one where the attacker could induce failure, say depending on some specific bit of N (which is of course unknown to A at the time). In a real execution of the protocol, since N is the output, A simply learns the bit ahead of time, which may not be critical in practise. However, in the simulated execution, A learns a bit of the simulated modulus, N, which may differ from the analogous bit of the modulus supplied by the ideal functionality, NFTHRES . Hence A may be able to distinguish between the executions. In this section we show that no such behavior is possible. Specifically, we show that if an execution with a malicious A results in N˜ = N, then this must have been computed using the correct shares of p and q. We do this by using A to break the semantic security of either ElGamal or Paillier encryption (cf. Definition 4). We distinct the cases of corrupted P0 and P1. P0 is corrupted. Let A denote an adversary controlling party P0 and denote by bad the event in which a malicious P0 sends in Step 3a of Protocol 1 encryptions of p˜ and q˜ with p˜0 ̸= p0 ∨ q˜0 ̸= q0 and an honest P1 does not abort the execution (where p0, q0 are the decryptions of ciphertexts sent in Step 2a using the ElGamal scheme). Then, conditioned on bad, we have that q˜0p1 + ˜p0q1 + q1p1 + ˜q0p˜0 ≡ N˜ mod N0 ≡ N mod N0 ≡ q0p1 + p0q1 + q1p1 + q0p0 mod N0, since the execution of πMULT ensures that P0 correctly adds the product of the two initial values in the final step, and N˜ ̸= N would be caught in the following step, causing P1 to abort. This implies that we know α = ˜q0 − q0, β = ˜p0 − p0, γ = ˜q0p˜0 − q0p0 ∈ ZN0 such that α · p1 + β · q1 + γ ≡ 0 mod N0 and either α ̸= 0 or β ̸= 0. These values will be used to determine information about p1 and q1 which may, in turn, be used to break the semantic security of ElGamal. More formally, assume bad occurs with probability ϵ. Then, construct an adversary AEG that breaks the semantic security of ElGamal with probability 1/2 + ϵ/2 as follows. Given an ElGamal public key pk′ EG = (g, h′ ), and a ciphertext cb which is an encryption of b ∈ {0, 1}, AEG simulates the initial key generation by replacing pkEG with pk′ EG (faking the proof that knows part of the decryption key). AEG then extract p0 and q0 from A’s ElGamal encryptions and generates two independent sets of candidates, p (0) 1 , p (1) 1 , q (0) 1 , q (1) 1 which will pass trial division. AEG then computes encryptions of one of the pairs: c (b) p1 = (cb) p (1) 1 −p (0) 1 Enc ( p (0) 1 ) c (b) q1 = (cb) q (1) 1 −q (0) 1 Enc ( q (0) 1 ) . 30 Note that in case b = 0, then c (b) p1 and c (b) q1 correspond to encryptions of p (0) 1 and q (0) 1 , respectively. Otherwise, we get encryptions of p (1) 1 and q (1) 1 . AEG then simulates the trial division (which is passed), and finally reach the step, where it computes N˜, and extracts p˜0 and q˜0 from A. Note that this allows AEG to compute α, β, and γ without even completing this step. A outputs 0 if and only if α · p (0) 1 + β · q (0) 1 + γ ≡ 0 mod N0. Due to πRSA, it holds that N0 is the product of two large primes with overwhelming probability. Neglecting the event where N0 is a product of more than two primes, it holds that p1 and q1 are co-primes to N0. In addition, if either GCD(α, N0) ̸= 1 or GCD(β, N0) ̸= 1, we may compute a factor f of N0, such that α ̸≡ 0 mod f ∨ β ̸≡ 0 mod f and both α and β co-prime with f unless congruent to 0. Otherwise let f equal the trivial factor, N0. As the execution would pass if it continued, it must holds that α · p1 + β · q1 + γ ≡ 0 mod f, i.e. we find a linear equation in p1 and q1. However, these will be either p (0) 1 , q (0) 1 or p (1) 1 , q (1) 1 depending on the unknown bit chosen by the ElGamal oracle. Hence, if A can cheat with probability ϵ, then AEG breaks the semantic security of ElGamal encryption with probability 1/2 + ϵ/2 by checking which pair of candidates gives a linear equation of the form specified above. Formally, AdvΠEG,AEG (n) = 1 2 ( Pr[AEG(c (b) p1 , c(b) q1 ) = 0|b = 0] + Pr[AEG(c (b) p1 , c(b) q1 ) = 1|b = 1]) = 1 2    
Pr[AEG(c (b) p1 , c(b) q1 ) = 0|b = 0] − Pr[AEG(c (b) p1 , c(b) q1 ) = 0|b = 1]    
 + 1 2 = Pr[bad|b = 0] − negl ≥ ϵ 2 + 1 2 where negl is a negligible function in the security parameter. The reason AEG outputs 0 with negligible probability in the case where b = 1 is due to the fact that p (1) 1 , q (1) 1 are independent of p (0) 1 , q (0) 1 and information theoretic hidden from A (as AEG either uses p (0) 1 , q (0) 1 or p (1) 1 , q (1) 1 ). Therefore, the probability that the outcome forms a linear equation for p (1) 1 , q (1) 1 is negligible. P1 is corrupted. Let A denote an adversary controlling party P1 and consider the event bad in which the honest P0 does not abort even though the malicious P1 computes cN˜−p0q0 differently than specified. Note that even if A returns a ciphertext cN˜−p0q0 , encrypting N − p0q0 and computed differently than specified in the protocol, the ZK proof πVERLIN enables to extract values x, x′ , x′′ ∈ ZN0 and rx ∈ Z ∗ N0 such that cN˜−p0q0 = c x · ( c ′ )x ′ · Enc(x ′′, rx), where c is an encryption of p0 and c ′ is an encryption of of q0. These values will be used to break either the semantic security of either ElGamal or Paillier encryptions. First, construct a distinguisher APa based on A which breaks the semantic security of Paillier encryption. Simulate steps I through IV, but use the Paillier key to break as N0; also extract p1 and q1 during the simulation. As ElGamal encryption is semantically secure, this will be indistinguishable from a real protocol run. 31 In step V, we receive a Paillier encryption cb of a bit b from the oracle. Similarly to above, we generate two sets of candidates, p (0) 0 , p (1) 0 , q (0) 0 , q (1) 0 which will pass trial division, and compute encryptions of one of the pairs: c p (b) 0 = (cb) p (1) 0 −p (0) 0 Enc ( p (0) 0 ) c q (b) 0 = (cb) q (1) 0 −q (0) 0 Enc ( q (0) 0 ) . We send c p (b) 0 and c q (b) 0 as the initial messages in the N˜-computation and fake the proofs of known plaintext. Once A has returned cN˜−p0q0 (which is an encryption of N − p (b) 0 q (b) 0 by assumption), we extract x, x ′ , x ′′ , and rx. Again, we do not need to finish this step of the protocol, but may directly use these values to break the semantic security. As N˜ = N, we have the following equation in the two unknowns p (b) 0 and q (b) 0 xp (b) 0 + x ′ q (b) 0 + x ′′ ≡ q1p (b) 0 + p1q (b) 0 + p1q1 mod N0 ⇕ (q1 − x) p (b) 0 + ( p1 − x ′ ) q (b) 0 + ( p1q1 − x ′′) ≡ 0 mod N0 There are two cases: Case 1: q1 − x = 0 ∨ p1 − x ′ = 0. In this case, we can compute either p (b) 0 and q (b) 0 : q (b) 0 = ( x ′′ − p1q1 ) (p1 − x) −1 p (b) 0 = ( x ′′ − p1q1 ) (q1 − x) −1 . This calculation requires that the non-zero value is invertible. However, if it is not, then we may compute a factor of N0 using GCD. This allows us to compute the decryption key ourselves, which trivially breaks semantic security. Case 2: q1 − x ̸= 0 ∧ p1 − x ′ ̸= 0. Again, we may assume that both q1 − x and p1 − x ′ are invertible. Similarly to the case of a corrupt P0, we now have a linear equation in p (b) 0 and q (b) 0 , and we can easily check which pair, ( p (0) 0 , q (0) 0 ) or ( p (1) 0 , q (1) 0 ) , fits the equation; this breaks the semantic security of Paillier encryption. If, on the other hand, Paillier encryption is semantically secure, then we may break the semantic security of ElGamal. Similarly to above, we may compute ElGamal encryptions of p (b) 0 and q (b) 0 . Then in the computation of N˜, we obtain x, x ′ , x ′′, and rx, which again may be split into two cases and used to break semantic security. C.2 A Proof of Theorem 8 for Securely Testing Biprimality Proof: The theorem states both correctness and security. By correctness we mean: If the parties do not deviate, then Blum integers are never rejected whereas, numbers with more than two prime factors are rejected with probability at least 2 −ℓ . Since the biprimality test is identical to the one of Boneh and Franklin [BF01], we refer the reader to [BF01] for a proof of correctness. Security: The security is proven in the FEQ-hybrid model. We assume that simulator S has knowledge of the shares of adversary A from protocol DKeyGen for distributively generating an RSA composite. Observe that there are two possible outcomes of DPrim, either N is rejected, in which case N is not a Blum integer in the real protocol. This can easily be simulated by S choosing shares on behalf of the honest player such that N is not a Blum integer and executing the real protocol as the honest party would. It is easy to verify 32 that if A deviates then it cannot make πEQ accept. In the other case, N is a Blum integer and should be accepted. Therefore, S has to be able simulate A’s view without knowing the factorization of N, which is possible in the following way. Assume that P0 is corrupted by A; the simulation is analog to below if P1 is corrupt. 1. S emulates the choice of γ by choosing a uniform random value a ∈ Z ∗ N with Jacobi symbol J (a) = 1 and a uniform random bit b ∈ {0, 1} and outputs γ = a 2 (−1)b mod N to the adversary A. 2. Each player are supposed to calculate e0 = EncpkEG ( N−(p0+q0)+1 4 ) , we note this is done with a simulated value for N. S receives γA from A, and since S has knowledge of the shares pA and qA of A, S knows a priori the expected value of γA. S emulates FEQ, by receiving ( N−(p0+q0)+1 4 ) as withness, and verifying whether γA is calculated correct. (Abort if γA is not the expected value) 3. Each player are supposed to calculate e1 = EncpkEG ( −(p1+q1) 4 ) , we note this is done with simulated values for p1 and q1. S sends γS = (γA) −1 (−1)b mod N to A and emulates FEQ accepting. 4. Finally, the parties rejects N if and only if γ0 · γ1 mod N ̸= ±1. The simulation of the additional test in the group (ZN [x]/(x 2 + 1))∗/Z ∗ N is analog to the simulation described above. Note the following: I. Because N is a Blum integer, the size of the subgroup of quadratic residues QR in Z ∗ N is half the size of the subgroup of elements with Jacobi symbol 1 in Z ∗ N . (−1) is a quadratic nonresidue modulo N with Jacobi symbol J (−1) = 1. This means that γ is a uniform random element of Z ∗ N with Jacobi symbol J (γ) = 1. This is the exact distribution in the real execution, since we assume A cannot influence the distribution of γ in DPrim. II. In the real world execution of DPrim the following holds: γ0 · γ1 ≡ 1 mod N if γ ∈ QR γ0 · γ1 ≡ −1 mod N if γ ̸∈ QR From b, S knows, whether γ is in QR or not, and therefore γS is simulated perfectly by γS = (γA) −1 (−1)b mod N. Finally, since all values except the encryptions e0 and e1 are simulated perfectly A can only distinguish the real and hybrid executions if it can break the sematic security of ElGamal, and therefore break the DDH assumption. C.3 A Proof of Theorem 10 for Securely Computing Multiplicative Shares of the Secret Key Due to the fact that this subproof is part of the larger proof for the threshold functionality, we assume that the simulator already knows the additive shares of the secret key chosen by the adversary. This is due to the fact that the simulator for the key generation protocol already extracts these. Now, as functionality FTHRES is reactive (in a sense that it is defined in phases), the simulator for the decryption phase is allowed to keep a state from the key generation phase. Proof: We consider two corruption cases here. The proof is presented in the FENC, FEQ-hybrid model. 33 P0 is corrupted. Let A denote an adversary controlling party P0. Then, construct a simulator S as follows. Let pk = N denote the newly generated public key, as given by the trusted party to S. Then, S continues as follows, it first receives the encryption e and the corresponding witness γ, r for FENC. If the conditions for accepting this witness are not met, S aborts the execution. Otherwise, upon receiving e ′ from the adversary and a potential witness for FEQ, S accepts only if this is a correct witness. Otherwise, S halts. S outputs whatever A does and records γ (for further usage). Then, the views are identically distributed in both executions since the only messages A sees are from the trusted party emulated by S. P1 is corrupted. The proof for this case is more challenging since the adversary indeed sees some information based on the honest party’s secret share. More formally, let A denote an adversary controlling party P1. Then, construct a simulator S as follows. S first chooses two random values γ, γ′ ∈ ZN and sends A at the beginning, the encryption of γ, denoted by e. It also emulates the trusted party for FEQ and sends 1 (for denoting the accepting message). Finally, S computes e ′ = (γ ′ · N + 1)/esk1 mod N 2 , where sk1 is the additive share of A. S sends e ′ together with a simulated proof instead of πEQ. Then, the difference between the hybrid and the simulated views is due to the fact that S computes e ′ differently than in the hybrid execution. We prove that the adversary’s view is computationally indistinguishable in both executions. Note first that in the hybrid execution the ciphertext e ′ is computed as follows, e ′ = ((1 + N) γ · r N ) sk0 = Encpk(γ · sk0; r sk0 ) On the other hand, in the simulated execution we denote by β = γ ′ −γ and have the following computation, e ′ = (γ ′ · N + 1)/esk1 = Enc(β + γ · (1 − sk1); r −sk1 ) = Enc(β + γ · (N + 1 − sk1); r ϕ(N)−sk1 ) = Enc(β + γ · (ϕ(N) + sk0); r sk0 ) where the subgroup generated by 1 + N is of order N. Therefore, γ · (1 − sk1) = γ · (N + 1 − sk1), (as γ · N = 0 mod N). Similarly, the order of r is ϕ(N). Note that the randomness distributes the same in both runs and the difference is with respect to the plaintext, where in the later computation we get a random plaintext which is independent of γ. Formally, the proof follows via the following sequence of games. Game H0. This game corresponds to the original simulation. Game H1. In this game there is no trusted party. Instead, we assume that the simulator S1 uses sk0 rather than sk1 to compute the ciphertext e ′ . Furthermore, S1 computes it as in the hybrid execution. Namely, it raises e to the power of sk0. Then, we claim that the adversary’s view between these games is computationally indistinguishable via a reduction to Paillier. Our proof reduces the gap between these games into the ability to distinguish in the semantically secure game (cf. Definition 4). More formally, assume there exists an adversary Aπ who attempts to distinguish two encryptions. Then, it internally invokes adversary A, while playing the role of P1 as follows. Instead of computing the plaintext e by itself, it output two random messages γ1, γ2. Denote by c the challenge ciphertext. Then, Aπ incorporates c into its execution with A as follows. It first sends c instead of e and emulates the trusted party for FENC. Next, it sends e ′ = c sk0 · (c/(1 + N) γ1 ) and a simulated proof instead of πEQ. Then, in case c encrypts γ1, the outcome distributes as in the hybrid execution. Else, the outcome corresponds to a random element in ZN , i.e., γ2 − γ1 + sk0 · γ2, which is independent of γ2. Finally, we note that the adversary’s view in game H1 and in the hybrid execution is identical, concluding the proof. 34 C.4 A Proof of Theorem 11 for Securely Decrypting As in the previous proof for generating multiplicative shares, we assume that the simulator already knows the additive and multiplicative shares of the adversary. The proof is shown in the FENC, FEQ-hybrid model. Proof: We distinguish two corruptions case here. P0 is corrupted. Let A denotes an adversary controlling party P0. Construct a simulator S as follows. 1. S interacts with A as follows. Upon receiving c ′ and the corresponding witness ω, r for FENC, S aborts in case the conditions for accepting this witness are not met. Otherwise, S receives c1 and a witness for FEQ. If the witness is invalid S halts. 2. S sends A the value (m + ω)/skM 0 mod N, where skM 0 denotes the multiplicative share of the adversary. 3. In the following iteration, S sends [a · (m + ω) + b]/skM 0 mod N. We claim that the adversary’s view distributes as in the hybrid execution. This is due to the fact that A computes c ′ and c1 as the honest P0 and so, it is excepted to receive the messages sent by the simulator above (which are the outcomes of the computations performed by the honest P1 in the hybrid execution). P1 is corrupted. We continue with the proof for the case that party P1 is corrupted. Let A denotes an adversary controlling party P0. Then, construct a simulator S as follows. 1. S chooses a random ω ∈ ZN and computes c ′ as the honest P0 does. It then sends A, c ′ and emulates the functionality for FENC. Finally, S picks a random ω ′ ∈ ZN , sends the adversary the value c1 = (ω ′ · (skM 1 ) −1 · N + 1)/(c · c ′ ) sk1 mod N 2 , and emulates the trusted party for FEQ. Denote τ the value that A returns upon completing this iteration. 2. In the following iteration, the simulator picks random a, b ∈ ZN and computes c ′′ as the honest party does. It then chooses a random b ′ ∈ ZN and computes c1 as above, except for using b ′ instead of ω ′ . Let τ ′ denote the value that A returns upon completing the second iteration. 3. Finally, S verifies whether A computed τ and τ ′ correctly by repeating its steps (recall that S knows the shares of A). If the verification fails, S aborts. Otherwise, it outputs whatever A does. The proof for which the adversary’s view is computationally indistinguishable follows from the proof for Theorem 10. We continue with a proof, showing that A cannot cheat in the computations of τ and τ ′ . Intuitively, this is due to the fact that A cannot produce a valid MAC to a new message (not even to a message of its choice). More formally, assume by construction that A is able to produce two messages τ and τ ′ such that, τ ̸= m + ω and τ ′ = a · τ + b. Then, construct an adversary Amac who breaks the security of the underlying MAC scheme as follows. Upon receiving from its challenger a MAC, M for a random message m of its choice, it continues as follows. Amac encrypts m and uses it instead of c ′ in the first iteration. It chooses a random element ρ ∈ Z 2 N∗ , for denoting the encryption of b and fixes c ′′ = Encpk(M). It then completes the executions with these values. Finally, it checks wether the values returned by A form a valid pair of a message and its MAC. In this case, Amac returns these values. 35 D The [DM10] Biprimality Test: The Two-Party Case This section describes how the biprimality test by Damgard and Mikkelsen [DM10] works, and how it is ˚ applicable in the two-party case in the honest-but-curious setting. How to adapt the test to the malicious case, without applying generic and rather inefficient zero knowledge proofs is currently unknown. As with the previous biprimality test the objective is to test a number N = pq, with p ≡ q ≡ 3 (mod 4) to check whether p and q are both primes. We assume N to be public and p and q to be additively shared between the two parties. The test is basically the Miller Rabin [Rab80] primaility test, run first on p and afterward on q, exploiting the fact that N is public to do this efficient. We also assume a distributed ElGamal scheme as described in section 2.2.2 is set up, and that P0 has generated a paillier key pair. First we note that using the Miller Rabin [Rab80] primaility test on a number p ≡ 3 (mod 4), all that is needed to test is whether γ (p−1)/2 ≡ ±1 (mod p) for a randomly picked γ ∈ Z ∗ p . Next we note that it does not make a difference if we randomly pick γ ∈ Z ∗ N . Focusing on p, the test verifies that γ (p−1)/2 ≡ ±1 mod p for a randomly picked γ ∈ Z ∗ N . First party Pi computes βi : β0 = γ (p0−1)/2 mod N β1 = γ −p1/2 mod N We note that: γ (p−1)/2 ≡ ±1 (mod p) (1) ⇕ γ (p0−1)/2 ≡ ±γ −p1/2 (mod p) (2) ⇕ (β0 mod p) = ± (β1 mod p) (3) where (2) to (3) follows from the fact that p|N; thus reducing βi modulo p is equivalent to reducing γ (pi−(1−i))/2 modulo p directly. It remains to be shown how to perform the modulo reductions and check for equality in (3) securely. Modulo Reductions an Equality Testing in (3): We first note, that: βi mod p = βi − ⌊ βi p ⌋ p, and we assume an approximation a (i) of ⌊βi/p⌋, where a (i) is held additively shared, a (i) 0 + a (i) 1 ; we show how to obtain this below. The rest of the calculation is done distributedly as: P0 sends ElGamal encryptions of β0, p0, a (0) 0 , a (1) 0 , p0 · a (0) 0 , and p0 · a (1) 0 to P1. Using the homomorphic property of the ElGamal scheme this allows P1 to compute encryptions of: βi − (p0 · a (i) 0 + p0 · a (i) 1 + p1 · a (i) 0 + p1 · a (i) 1 ) = βi − (a (i) 0 + a (i) 1 ) (p0 + p1) = βi − ⌊ βi p ⌋ · p = (βi mod p) + kip for i ∈ {0, 1}, where the ki’s are small integer values due to the fact that the a (i) are only approximations. If (and only if) β0 ≡ β1 mod p (respectively β0 ≡ −β1 mod p), the difference (respectively sum) will be a small multiple of p. Hence, we may check whether β0 ≡ ±β1 mod p using a small number of equality tests (β0 + β1 = 0, (β0 + β1) − p = 0, (β0 + β1) − 2p = 0, etc): First the parties randomly permute the ciphertexts in question; then they raise each one to a random, non-zero exponent; finally the parties decrypt each cipher text – if one was an encryption of 0, they conclude that β0 ≡ ±β1 mod p. This leaks no information due to the (secret) permutation and random exponentiations. 36 Computing a (i) ≈ ⌊βi/p⌋: The approximation, a (i) , of ⌊βi/p⌋ is obtained by first computing a˜ (i) = ⌊ 2 m N ⌋ · (q0 + q1) · βi ≈ ⌊ 2 m · (q0 + q1) · βi N ⌋ = ⌊ 2 m · βi p ⌋ which is an approximation of 2 ma (i) , where m is a bit-length ensuring that a (i) will be sufficiently accurate, making k, the number of tests, above sufficiently small. For a thoroughly analysis of the size of m, the reader is referred to [DM10]. An additive sharing of a˜ (i) over the integers may be computed based on Paillier encryption with P0’s keys. The Paillier key, has to be sufficiently big, such that the following calculations, will not lead to an overflow modulo the modulus. This implies that the following calculations are done over the integers, although they are done modulo the modulus of the Paillier key. The value ⌊ 2m N ⌋ is a public value, and the rest is integer computation, thus: P0 sends encryptions of q0, β0 and q0 · β0 to P1, which for i ∈ {0, 1} computes encryptions of the values: a˜ (i) = ⌊ 2 m N ⌋ · (q0βi + q1βi) = ⌊ 2 m N ⌋ · q · βi Finally P1 picks two uniformly random values a˜ (i) 1 κ bits longer than the a˜ (i) , where κ is a security parameter, and returns and encryptions of a˜ (i) 0 = ˜a (i) − a˜ (i) 1 to P0 for i ∈ {0, 1}. P0 decrypts and stores both a˜ (i) 0 as negative integers, i.e. views NPa − x ∈ ZNPa as −x ∈ Z, NPa denoting the modulus in the Paillier key. The parties then truncate their values (drop the least significant m bits); denote the truncated values a (i) 0 and a (i) 1 , and note that their sum is the required approximation, a (i) : a (i) 0 + a (i) 1 ≈ a˜ (i) /2 m ≈ ⌊ 2 m · βi · q 2mN ⌋ ≈ ⌊βi/p⌋ . E Generalizing to the Multiparty Case Our protocol may be generalized to the multiparty case in the setting with dishonest majority and a static adversary. Our construction is comprised of the following two parts: 1) securely determining the modulus N, and 2) obtaining a threshold Paillier key. To the best of our knowledge, this is the first multiparty protocol for a distributed RSA composite generation, which is actively secure against an adversary corrupting all but one of the parties. Moreover, despite Cramer et al. [CDN01] and Damgard and Nielsen [DN03] demonstrating ˚ efficient, general multiparty computation given only a public Paillier key with a shared secret key (provided by some third-party, which could be replaced by a secure protocol), previous papers on RSA composite generation have disregarded the shared Paillier decryption key and focused solely on generating the modulus. We are the first to present a protocol for generating a full, distributed Damgard-Jurik key ˚ 3 [DJ01]. For clarity, we take a high-level view of these protocols. Further, as the protocols are described with clarity, rather than efficiency, in mind, many straightfoward optimizations are possible. 3Our key differs slightly, however, the principles and the construction are essentially the same. 37 In the following, let k denote the number of parties, P1, . . . , Pk, and let t denote the desired threshold for the shared Paillier key computation. For both parts, we ensure security against an adversary corrupting up to t − 1 parties, though naturally, given the threshold key any t parties may perform a decryption or reconstruct the secret key. A few remarks are in place here. We first assume that the parties have access to PKI setup. That is, each party has a public verification key which all parties hold a copy of. Based on this, we may construct a broadcast channel. In addition, we allow any party to halt the protocol at any time by broadcasting an abort message. When this occurs, all parties broadcast all messages of the entire protocol (including all signatures) as well as all randomness used in all key generations, encryptions, etc. At this point it is easy to verify the behavior of all parties and assign blame. We may do this as there are only random inputs to the protocol picked by the participants, i.e. leaking them does not compromise any privacy.4 We remark that care must be taken when running sub-protocols in parallel. For example, a rushing adversary could potentially break the entire protocol by using a ZK-proof of an honest party to fake a ZKproof of its own. The issues can be removed, e.g. by using broadcasts to ensure complete synchronization, and having all parties commit to all messages in a given round before actually sending them. E.1 Generating an RSA Composite In this section we describe our protocol for generating as RSA composite N = (∑k i=1 pi ) (∑k i=1 qi ) , for pi , qi being the shares picked by the ith party. We note that most of the steps of our multiparty protocol translate directly from our two-party construction. 1. KEY-SETUP. • The parties run the k-party generalization of the shared ElGamal key generation: The parties agree on the group of sufficiently large order, Q, and a generator, g. Each party Pi picks a uniformly random xi ∈ ZQ, broadcasts hi = g xi , and proves knowledge of a DL of hi to all others. The ElGamal key is now h = ∏k i=1 hi . Decryption is analogous to the two-party case. • Each party Pi generates and broadcasts a Paillier key, Ni ≫ Q2 , and proves that it is well-formed to all other parties. 2. GENERATE CANDIDATES. • We employ the same idea as used by Boneh and Franklin, [BF01]: Each party Pi generates a random share pi for p = ∑k i=1 pi . The parties broadcast ElGamal encryptions of their shares and prove to all others that they know the plaintexts and that these are of appropriately bounded size using ZK proofs πENC and πBOUND. Similarly to above, the parties ensure that the share of P1 is congruent to 3 mod 4, while all others are congruent to 0. • Trial division is analogous to the two-party protocol. The parties broadcast encryptions of pi mod α for all primes α < B. Using the homomorphic property, the parties compute an encryption of the sum, and check if this is an encryption of a multiple of α, i.e. whether it is one of the values within [0, α, 2α, . . . ,(k − 1)α]. Correct behavior is verified with πMOD. • Repeat the previous steps to generate the second candidate, q, as well. 3. COMPUTE PRODUCT (N = pq). 4 See Footnote 2. 38 • This step differs significantly; obtaining g N could easily be done [CDN01], however, N˜ cannot be computed as in the two-party case, hence we would have to obtain the solution to the DL problem differently. The main idea here is to have every pair of parties, Pi and Pj , engage in a protocol to obtain an additive sharing over ZQ of piqj = s (i) i,j + s (j) i,j instead.5 Note that no other party receives shares of this value. Each party then locally adds all shares held, thereby obtaining a share from an additive sharing of pq = ∑ k i=1 ∑ k j=1 piqj = ∑ k i=1 ∑ k j=1 ( s (i) i,j + s (j) i,j ) . (4) Additionally, ZK proofs on ElGamal encryptions are used to ensure that parties are committed to their shares and behave as specified. More formally, – For 1 ≤ i, j ≤ k, Pj broadcasts an ElGamal encryption of a uniformly random value, −s (j) i,j ∈ ZQ, and proves in ZK towards all others that it has known plaintext using πENC. – For 1 ≤ i, j ≤ k, Pi sends a Paillier encryption cpi,j of pi to Pj under its own key, Ni . 6 Moreover, for each one, it proves plaintext knowledge using πENC and that the value is bounded using πBOUND. – For 1 ≤ i, j ≤ k, Pj computes a Paillier encryption under key Ni c¯i,j = (cpi,j ) qj · Enc ( −s (j) i,j + Q · ri,j) , where ri,j is a uniformly random n-bit value which statistically masks any overflow modulo Q in the computation. c¯i,j is then sent to Pi along with a ZK proof that the computation was done using known values. This can e.g. be done using πVERLIN and an additional dummy encryption of 0. It is straightforward to construct a simpler protocol similar to πVERLIN; naturally this would be more efficient. – For 1 ≤ i, j ≤ k, Pi decrypts c¯i,j , reduces the resulting plaintext modulo Q, and denotes the result s (i) i,j . Pi then broadcasts an ElGamal encryption of s (i) i,j and proves plaintext knowledge, πENC. – For 1 ≤ i, j ≤ k, the parties verify that everyone is indeed committed to shares of the products, piqj . Based on the encryption of qj , party Pi computes and broadcasts a fresh encryption of piqj ; correctness is verified by executing πMULT. All parties then compute an ElGamal encryption of piqj − ( s (i) i,j + s (j) i,j ) , (5) using the homomorphic property. This encryption is then decrypted, and all parties verify that the obtained plaintext equals zero. This demonstrates that s (i) i,j +s (j) i,j = piqj , i.e. that the sharing was indeed of the product. If any check fails, the parties abort the entire execution. – For 1 ≤ i ≤ k, all parties compute an ElGamal encryption of si = ∑ k j=1 s (i) i,j + s (i) j,i using the homomorphic property. Pi the broadcasts si , the parties decrypt the encryption of si (resulting in the value g si ), and finally verify that the broadcast value is correct, i.e. the DL of the decrypted value. 5 For i = j, the party in question simply computes a dummy sharing of the known value piqj . 6 For efficiency, Pi may send the same encryption to all other parties; we do not demand this behavior, though. 39 – The parties compute N = ∑k i=1 si mod Q. 4. BIPRIMALITY TEST. • P1 has the share congruent to 3 mod 4, and therefore behaves as P0 in the two-party protocol, while the rest behave as P1 in the two-party case. Each party broadcasts its γi ; P1 proves consistency towards an encryption of (N −p1−q1+1)/4 using πEQ, while Pi proves consistency towards −(pi + qi)/4 for 1 < i ≤ k. Correctness: Except for the computation of N = pq, all steps are essentially the same as in the two-party protocol. Focusing solely on this step, we note that it is easily verified that the right result is obtained, by Equation (4), since all parties explicitly verify that the encrypted shares indeed sum to the products, piqj . Security: Again, as all steps are analogous to the two-party protocol except for the computation of N, the security of these is shown (essentially) in the same way as security for the two-party protocol. Regarding the computation of N, we must ensure that no party can deviate from the protocol in any way without being detected. The computation of the additive sharing of N based on the parties’ Paillier keys can be viewed as a number of two-party computations (of additive secret sharings of products), which must be globally verifiable. This is achieved, since it is verified using Equation (5) that the sum of the encrypted shares of the product equals the encrypted product; the latter is guaranteed to be correct due to the use of πMULT. Thus, even if both Pi and Pj are corrupt, they will be committed to a sharing of the product. Further, a corrupt Pi can obtain no information about qj as the addition of −s (j) i,j +Q· ri,j statistically masks any information.7 A corrupt Pj on the other hand learns nothing about pi , as it only sees semantically secure encryptions. Similarly, if both Pi and Pj are honest, then the attacker only sees the semantically secure encryptions transferred, which leaks no information. Formal simulation is possible by giving the adversary either fresh, random encryptions or encryptions of random values distributed as the statistical mask depending on whether it knows the secret key. E.2 Computing the Threshold Key In this section we present a protocol for generating a threshold key for (a slight variation of) the Damgard- ˚ Jurik generalization of Paillier encryption [DJ01]. Recall that decryption consists of raising to the power of d, where d ≡ { 0 mod ϕ(N) 1 mod N Constructing a threshold key essentially consists of computing a Shamir sharing of this. Our solution consists of two steps: 1) First, compute an additive sharing of d. 2) Then, compute Shamir shares of this and decrypt these toward the relevant parties. Computing an additive sharing of d: First note that ϕ(N) · ( ϕ(N) −1 mod N ) ≡ { 0 modϕ(N) 1 modN (6) where ϕ(N) and (ϕ(N) −1 mod N) are viewed as integers. The key primitive of the construction is to add secure multiplication and full decryption to the ElGamal scheme by maintaining a secret state based on 7Note that the application of πBOUND on ciphertext cpi,j is critical, as this guarantees an honest Pj that its masking will hide qj . 40 additive secret sharing: The parties implicitly hold additive secret sharings of ϕ(N): P1 holds N + 1 − (p1 + q1), while Pi holds −(pi + qi) for 1 < i ≤ k. Further, the primary goal here is to compute an additive sharing of ϕ(N) −1 mod N. This will then be multiplied with the shared ϕ(N). To invert ϕ(N), the parties utilize the inversion protocol of Bar-Ilan and Beaver, [BB89], simulating ZN arithmetic in ZQ. Secure multiplication as well as decryption is achieved, by utilizing the ElGamal encryptions as commitments to the shares of the parties. The crucial observation is that when the parties hold additive sharings (over ZQ) and are committed to those shares – through public ElGamal encryptions of each share – they may obtain an additive sharing of the product as well as ElGamal encryptions of these shares. The protocol, which we denote πΠ, is essentially the same as the one used for computing N = pq above. Note that this construction is similar in structure to the protocols of Bendlin et al. [BDOZ11]. • For 1 ≤ i ≤ k, party Pi picks ti uniformly at random from ZN and ri uniformly at random from ZN·k·2n , where n is a security parameter. Each Pi then broadcasts ElGamal two encryptions, cti of ti and cri of ri , and demonstrates plaintext knowledge and that they belong to the specified domains using πENC and πBOUND. These will be viewed as sharings of random values, t = ∑k i=1 ti and r = ∑k i=1 ri . • The parties execute πΠ, obtaining shares u1, . . . , un of t · ϕ(N) as well as encryptions cui of those shares. • For 1 ≤ i ≤ k, party Pi broadcasts ui + N · ri ; the parties then decrypt cui ·(cri ) N , and verify that Pi broadcast the share correctly. If all checks succeed, the parties compute v = ∑ k i=1 ui + N · ri . Note that due to the restrictions on the ti and ri , v ≡ t · ϕ(N) mod N. • Each party locally computes the public value8 v¯ = v −1 mod N; this is then used to compute an additive sharing of w = t · v¯; Pi locally multiplies ti by v¯ to compute wi , and all parties raise the encryptions of the ti to v¯ to obtain encryptions of the wi . • Finally, the parties execute πΠ on the shared values ϕ(N) and w, thereby obtaining shares di of d along with encryptions cdi of the di . Correctness follows from the fact that the shared w = ∑k i=1 wi equals ( (t · ϕ(N) + r · N) −1 mod N ) · t = ( ϕ(N) −1 mod N ) + zN for some integer z of at most ⌈log k⌉ + ⌈log N⌉ bits. This implies that d = ((ϕ(N) −1 mod N ) + zN) · ϕ(N) = (( ϕ(N) −1 mod N ) ϕ(N) + zϕ(N)N. Note that the (at most) ⌈log k⌉+ 3⌈log N⌉-bit value, d, is a proper decryption exponent, as it clearly satisfies d ≡ { 0 mod ϕ(N) 1 mod N 8 v is invertible except with negligible probability. 41 Assuming that πΠ securely computes shares of products, then security follows from the fact that the only possible leak is v = ∑ k i=1 ui + N · ri . However, this may be simulated as it is statistically close to a large, random value: • v mod N ∈ Z ∗ N is the product of t and ϕ(N). Since t is the sum of uniformly random values ti < N, t mod N is (except with negligible probability) uniformly random in Z ∗ N , and – as Paillier encryption requires gcd(N, ϕ(N)) = 1 – therefore so is v mod N. Note that if t mod N ̸∈ Z ∗ N , then we abort. • Since ⌊v/N⌋ = ⌊u/N⌋ + r and r is random and n bits longer than ⌊u/N⌋, then ⌊v/N⌋ is statistically indistinguishable from a random value distributed as r, even if all but one of the parties are corrupt. Convert the additive sharing of d to a Shamir sharing: Given the additive sharing of d modulo Q, i.e. di held by party Pi and the public encryptions cdi of the di , the parties may compute a “Shamir sharing” of d. Damgard and Jurik do this over the ring ˚ ZNϕ(N) , however, here this must be done over the integers, as Nϕ(N) is unknown. The parties do this by converting the initial sharing of d to an additive sharing over the integers. In the following, let ℓd = ⌈log n + 3 log N⌉ be the bit-length of d. 1. Conversion to an integer sharing is done by adding a statistically hiding mask to d; the shares then depend on the masked value and the shares of the mask. • For 1 ≤ i ≤ k, party Pi picks ri uniformly at random from Z2 ℓd+n , where n is a security parameter. Pi then broadcasts an ElGamal encryption cri of ri , and proves in ZK that it knows the plaintext and that ri is of the specified size using πENC and πBOUND. • For 1 ≤ i ≤ k, party Pi broadcasts mi = di + ri . Moreover, the parties decrypt cdi · cri and verifies the correctness of the share. • Party P1 sets its integer share of d to be d1,Z = (∑ k i=1 mi mod Q ) − r1; all parties compute an encryption cd1,Z of d1,Z. • For 1 < i ≤ k, party Pi computes its integer share di,Z = −r1; all parties compute an encryption cdi,Z of di,Z. 2. Next, the di,Z are threshold shared. Each party Pi threshold-shares di,Z and demonstrates that it has done this correctly • For 1 ≤ i ≤ k and 1 ≤ j < t, party Pi picks ai,j uniformly at random in Z2 2 log(N)+n where n is the statistical security parameter, and broadcasts an ElGamal encryption cai,j of this. Moreover, it demonstrates knowledge of the plaintext ai,j and that ai,j < 2 2 log(N)+n using πENC and πBOUND. These will be the coefficients used to share di,Z; let fi(X) = di,Z + ∑ t−1 j=1 ai,j · Xj . Note that ai,j mod Nϕ(N) is statistically close to uniformly random. 42 • For 1 ≤ i, j ≤ k, the parties compute encryptions cfi(j) of fi(X) evaluated at point j. Further, Pi additively shares fi(j) over the integers among the players; denote Pι’s share sfi(j),ι. Pi broadcasts ElGamal encryptions csfi (j),ι of these and demonstrate that the plaintexts are known and of bounded bit-length, ℓs: ℓs = max ( ℓd; (logt n)(2 log(N) + n)(log t) ) + n Moreover, the parties decrypt ( cfi(j) )−1 · ∏k ι=1 csfi (j),ι and verify that the plaintext is 0, i.e. that Pi actually shared the evaluation at fi(j). • For 1 ≤ j ≤ k, the parties compute additive shares of f(j) = ∑ k i=1 fi(j); in addition, they use the homomorphic property to compute encryptions, cf(j),ι of these values. 3. Finally, for 1 ≤ j ≤ k, the parties must reveal the jth threshold share to party Pj . Damgard and ˚ Jurik reduce modulo Nϕ(N) first, which we cannot do. Hence to ensure no additional information is revealed, a large, random multiple of Nϕ(N) is added to each share. • Since N is public and an integer-sharing of ϕ(N) is given, it is simple for the parties to obtain an integer-sharing of Nϕ(N): each party simply multiplies its share by N. Further, the parties compute ElGamal encryptions of these new shares, by raising the encryptions of the shares of ϕ(N) to the power of N. • For 1 ≤ i, j ≤ k, party Pi broadcast encryptions of uniformly random, (ℓs+log k−2 log N +n)- bit values ri,j along with proofs that they are known and of bounded size. • For 1 ≤ j ≤ k, the parties execute πΠ on the set of ri,j and the sharing of Nϕ(N). Each party Pi then adds its share of f(j) to this, and denote this σi,j . Moreover, the parties compute ElGamal encryptions cσi,j for all these shares using the homomorphic property. • For 1 ≤ j ≤ k, party Pi sends the share σi,j to Pj . Moreover, the parties decrypt the cσi,j towards Pj , who verifies that it has received the correct shares; finally each Pj computes its share of d, σj = ∑k i=1 σi,j ≡ f(j) mod Nϕ(N). Correctness is straightforward: The polynomial f has been constructed over the integers. Clearly f(0) ≡ d mod Nϕ(N). Security follows from the fact that all messages received are either encrypted or random shares, and thus simulatable. The final values, σj are statistically indistinguishable from points on a random polynomial over ZNϕ(N) plus a sum of uniformly random, (ℓs + log n − 2 log N + n)-bit multiples of Nϕ(N). Paillier decryption To perform a Paillier decryption with the new threshold key, the parties must raise the ciphertext in question to the power of the share of the key. To prevent malicious behavior, each party must prove in ZK that this has been done correctly – i.e. prove in ZK that the exponent used is also stored in some commitment. Hence, to conclude the key generation, the parties compute and decrypt the ElGamal encryptions ∏k i=1 σi,j for 1 ≤ j ≤ k. They thereby obtain g σj . Using πEQ they parties may show equality of two exponents, i.e. show that they have raised a ciphertext to their part of the key. This differs from [DJ01] who perform this secondary exponentiation modulo a power of N. 43 View publication stats


